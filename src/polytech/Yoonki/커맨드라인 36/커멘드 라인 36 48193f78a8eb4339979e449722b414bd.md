# 커멘드 라인 36

## 그룹명령과 서브쉘

### 그룹명령

```bash
{ commandl; command2; [ command3; .. . ] }
```

서브쉘

```bash
(commandl; command2; [ command3;...])
```

그룹 명령은 중괄호로 해당 명령 어들을 감싸고 서브쉘은 괄호를 사용

## 리다이렉션 수행

>을 통해 리다이렉션이 가능

```bash
#그룹명령
{ ls -1; echo "Listing of foo.txt"; cat foo.txt; } > output.txt

#서브쉘 방식
(ls -1; echo "Listing of foo.txt"; cat foo.txt) > output.txt
#파이프 응용
{ ls -1; echo "Listing of foo.txt"; cat foo.txt; } Ilpr
```

## 프로세스 치환

서브쉘의 출력을 리다이렉션의 목적에 맞게 일반적인 파일로 처리하도록 허용

```bash
echo <(echo "foo") 
/dev/fd/63
```

read를 포함한 반복문에 사용

```bash
#!/bin/bash
# pro-sub : demo of process substitution
while read attr links owner group size date time filename; do
cat «- EOF Filename :
Size:
Owner : Group : Modified: Links : Attributes :
$filename $size $owner $group $date $time $links $attr
EOF
done < <(ls -1 I tail -n +2)
```

## 트랩 (Traps)

우리가 크고 복잡한 스크립트를 설계할 때, 시용자가 스크립트를 실행 중에 로그아웃 하거나 시스템을 종료하는 상황을 고려해야 한다. 
이러한 이벤트가 발생하면, 시그널은 영향력이 미치는 모든 프로세스 들에 전해지게 된다. 
따라서 이 프로세스 들이 가리키는 프로그램들은 순차적으로 적절히 프로그램 종료 작업을 진행할 수 있다.
예를들어, 실행중에 임시파일을 생성하는 스크립트를 만든다고 치자.
좋은 설계 방법은 스크립트가 작업을 마칠때 그 파일을 삭제하는 것이다. 
또한 프로그램이 종료되기 직전을 가리키는 시그널을 받으면 파일을 삭제하는 스크립트를 작성하는 것도 괜찮은 방법이다.
bash는 이를 위해 트랩(trap)이라는 기법을 제공한다. 트랩은 그에 걸맞은 이름인 trap 빌트인 명령으로구현되었다.

```bash
trap argument signal [signal ... ]
```

```bash
#!/bin/ bash
# trap-demo : simple signal handling demo
trap "echo 'I am ignoring you. '" SIGINT SIGTERM
for i in {1..5}; do
echo "Iteration $i of 5"
sleep 5
done
```

이 스크립트는 실행 중에 SIGINT 또는 SIGTERM 시그널을 받으면 echo 명령을 실행하는 트랩을 정의한다. 사용자가 스크립트를 멈추려고 CTRL-C를 누르면. 프로그램은 다음과 같이 동작할 것이다.

![스크린샷 2023-05-02 오전 2.27.51.png](%E1%84%8F%E1%85%A5%E1%84%86%E1%85%A6%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%2036%2048193f78a8eb4339979e449722b414bd/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-05-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.27.51.png)

## 비동기실행

비동기 방식은 동시에 하나 이상의 작업을 수행할때 적합하다.

부모 또는 자식이 상호 의존적이고. 하나 의 스크립트가 해당 작업을 완료하기 전에 다른 스크립트의 실행이 완료될 때를 기다려야만 한다면 어떻게 해야할까?

비동기 실행의 관리를 도와주는 빌트인 명령어

### wait

부모스크립트

```bash
#! / bin/ bash
# async-parent : Asynchronous execution demo (parent)
echo "Parent: starting..."
echo "Parent : launching child script . .. "
async-child & 
pid=$!
echo "Parent: child (PID= $pid) launched."

echo "Parent: continuing..."
sleep 2

echo "Parent: pausing to wait for child to finish..."
wait $pid

echo "Parent : child is finished. Continuing..."
echo "Parent : parent is done. Exiting ."
```

자식스크립트

```bash
# ! / b i n / ba s h
# asy nc-child : Asynchronous execution demo (ch i l d)
echo "Child: child is running..." 
sleep 5
echo "Child: child is done. Exiting."
```

결과

![스크린샷 2023-05-02 오전 2.33.28.png](%E1%84%8F%E1%85%A5%E1%84%86%E1%85%A6%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%2036%2048193f78a8eb4339979e449722b414bd/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-05-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.33.28.png)

## 네임드 파이프(Named Pipes)

특수한 종류의 파일을 생성

두 프로세스를 연결하기 위해 사용되고 다른 종류의 파일들처럼 파일로 써 사용될 수 있다.

클라이언트/서버 : 웹 브라우저와 그와 통신하는 웹서버

네임드 파이프는 파일처럼 동작하지만 실제로는 선입선출(FIFO) 버퍼 형태

![스크린샷 2023-05-02 오전 2.35.12.png](%E1%84%8F%E1%85%A5%E1%84%86%E1%85%A6%E1%86%AB%E1%84%83%E1%85%B3%20%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%2036%2048193f78a8eb4339979e449722b414bd/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-05-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.35.12.png)

### 네임드 파이프 설정

```bash
mkfifo pipel
ls -1 pipel
```

prw-r--r-- 1 me me 0 2012-07-17 06:41 pipe 1

### 네임드 파이프 사용

```bash
ls -1 > pipel
```

```bash
cat < pipel
```