---
layout home
--- 

# 리눅스 프로그래밍

## 파일과 디렉토리

## 1. 파일 기본 사항

리눅스에서 디렉토리의 위치는 절대 경로와 상대경로로 표시됩니다.

→ 윈도우에서 최상위 경로는 하드디스크 등 디바이스의 최상위 디렉토리(폴
더)로 예를 들어 ‘c w'로 표시되며 . 이때 최상위 경로는 슬래시 기호 ‘\', ‘W'
로 표시됩니다. 유닉스와 리눅스에서는 슬래시가 아닌 역 슬래시 ‘/' 기호가 최
상위 디렉토리이며, 루트(root) 디렉토리라고 읽습니다.
<br/><br/><br/>

### 절대 경로와 상대 경로

1. 절대 경로 (Absolute Path)
절대 경로는 루트 디렉토리에서 시작하여 파일이나 디렉토리가 있는 위치를 나타내는 경로입니다. 따라서, 절대 경로는 항상 **`/`**로 시작합니다. 예를 들어, **`/usr/bin`**은 루트 디렉토리에서 시작하여 **`usr`** 디렉토리 안에 있는 **`bin`** 디렉토리를 나타냅니다.

1. 상대 경로 (Relative Path)
상대 경로는 현재 작업 중인 디렉토리에서부터 파일이나 디렉토리가 있는 위치를 나타내는 경로입니다. 상대 경로는 **`.`** 또는 **`..`**과 같은 특수 문자를 사용하여 상대적인 위치를 나타냅니다. 예를 들어, 현재 작업 중인 디렉토리가 **`/home/user`**이고, **`user`** 디렉토리 안에 **`documents`** 디렉토리가 있다면, **`./documents`**는 현재 작업 중인 디렉토리에서부터 **`documents`** 디렉토리를 나타내는 상대 경로입니다. 또한, **`../pictures`**는 현재 작업 중인 디렉토리에서 상위 디렉토리인 **`user`** 디렉토리 안에 있는 **`pictures`** 디렉토리를 나타내는 상대 경로입니다.

<br/><br/><br/>
### 파일 탐색 명령어

- pwd (디렉토리 절대경로 출력)

```bash
# 현재 작업 중인 디렉터리의 절대 경로를 출력
$ pwd
```

- cd (디렉토리 이동)

```bash
$ cd . # 현재 디렉토리로 이동

$ cd .. # 상위 디렉토리로 이동

$ cd ~ # 현재 사용자의 홈 디렉토리로 이동

$ cd / # 루트 디렉토리로 이동

$ cd   # 홈 디렉토리로 이동

$ cd - # 바로 이전 디렉토리로 이동
```

- ls (디렉토리 / 파일 확인)

```bash
$ ls # 현재 디렉토리 구성 내용 출력

$ ls [디렉토리 명] # 지정한 디렉토리 구성 내용 출력

$ dir # 윈도우 명령어 dir도 사용가능. 단 하이라이팅이 없음.
```

### 파일 내용 확인 명령어

- cat (****파일 내용 전체 출력****)

```bash
$ cat file1 # : file1의 내용을 출력

$ cat file1 file2 # : file1과 file2의 내용을 출력

$ cat file1 file2 | more # : file1과 file2의 내용을 페이지별로 출력

$ cat file1 file2 | head # : file1과 file2의 내용을 처음부터 10번째 줄까지만 출력

$ cat file1 file2 | tail # : file1과 file2의 내용을 끝에서부터 10번째 줄까지만 출력
```

- more (****파일 내용 페이지 단위로 출력****)

```bash
$ more [option] file 
# -num : 스크린에 한번에 보여줄 줄수를 설정.

$ more +100 anaconda-ks.cfg # -> 100행부터 출력
```

- page

- head (****파일 내용 앞부분 출력)****

→ 지정한 파일의 앞부분을 출력

→ 옵션을 지정하지 않으면 첫 10줄을 출력

```bash
$ head [option] file 
# -n,--lines : 출력할 줄 수를 지정
# -c,--byte : 출력한 바이트수를 지정

$ head -5 anaconda-ks.cfg # 앞에서 5행만 출력
```

- tail (****파일 내용 뒷부분 출력****)

→ 지정한 파일의 끝 부분을 출력

→ 옵션을 지정하지 않으면 뒷 10줄 출력

```bash
$ tail [option] file 
# -n,--lines : 파일의 마지막에서 지정한 줄만큼 출력
# -c,--bytes : 파일의 마지막에서 지정한 바이트 수만큼 출력
# -f,--follow : 새로운 데이터가 들어올때까지 모니터링

$ tail -5 anaconda-ks.cfg # 뒤에서 5행만 출력
```

### 파일 다루는 명령어

- mv (디렉토리 /  파일 이동)

```bash
$ mv [이동할 디렉토리] [대상 디렉토리]
```

```bash
[옵션]

$ mv -b # : 목적 경로에 같은 이름의 파일(혹은 디렉토리)가 존재하면, 기존 파일을 백업 후 이동.

$ mv -f # : 목적 경로에 같은 이름의 파일(혹은 디렉토리)가 존재하면, 덮어쓸 것인지 묻지 않고 바로 덮어쓴다. 

$ mv -i # : 목적 경로에 같은 이름의 파일(혹은 디렉토리)가 존재하면, 덮얼쓸 것인지 물어본다

$ mv -v # : 이동중인 상태를 표시
```

- cp (디렉토리 / 파일 복사)

```bash
$ cp -r [복사할 디렉토리] [대상 디렉토리]
```

```bash
[옵션]

$ cp -a # : 원본 파일의 속성, 링크 정보들을 그대로 유지하면서 복사

$ cp -b # : 복사할 대상이 이미 있을 경우 기존 파일을 백업하고 복사

$ cp -d # : 만약 복사할 원본이 심볼릭 링크일 때 심볼릭 자체를 복사

$ cp -f # : 만약 복사할 대상이 이미 있으면 강제로 지우고 복사

$ cp -i # : 만약 복사할 대상이 이미 있으면 사용자에게 물어본다

$ cp -l # : 하드링크 형식으로 복사

$ cp -P # : 원본 파일 지정을 경로와 같이했을 경우 그 경로 그대로 복사

$ cp -p # : 파일의 소유자, 그룹, 권한, 시간 정보들이 그대로 보존되어 복사

$ cp -r # : 원본이 파일이면 그냥 복사되고 디렉터리라면 디렉터리 전체가 복사

$ cp -s # : 파일을 심볼릭 링크 형식으로 복사. 단, 원본 파일이름을 절대 경로로 지정해야 한다.

$ cp -u # : 복사할 대상이 있을 때 이 파일의 변경 날짜가 같거나 더 최근의 것이면 복사하지 않는다.

$ cp -v # : 복사 상태를 보여줌

$ cp -x # : 원본과 대상 파일의 파일시스템이 다를 경우에는 복사하지 않는다.

$ cp -R # : 디렉터리를 복사할 경우 그 안에 포함된 모든 하위경로와 파일들을 모두 복사
```

- rm (****파일/디렉토리 삭제)****

→ • rmdir 과 다르게 디렉토리 삭제 시 **안에 파일이 존재해도 삭제 가능**

```bash
$ rm file1 # : file1을 삭제

$ rm -f file1 # : file1을 강제 삭제

$ rm -i file1 # : 삭제하기전에 사용자 확인

$ rm -r dir # : dir 디렉터리 삭제 (디렉터리는 -r 옵션 없이 삭제 불가)

$ rm *[공통으로 끝나는 확장자] # : 공통으로 끝나는 확장자로 끝나는 파일 모두 삭제 

$ rm * # : 모든 파일 삭제
```
<br/><br/><br/>
### 명령어 히스토리

- r 또는 !
- 화살표 위와 아래
- 명령어 히스토리 저장 파일
<br/><br/><br/>
### 디렉토리 관리

- mkdir (디렉토리 생성)

```bash
$ mkdir [디렉토리 명]

# 디렉토리 여러개 생성
$ mkdir [디렉토리명1] [디렉토리명2] [디렉토리명3]

# 하위 디렉토리 경로대로 생성
$ mkdir -p temp/ex1/ex2
```

- rmdir (디렉토리 삭제)

```bash
# 디렉토리 삭제. 단 하위 디렉토리가 없는 빈 디렉토리여야지 가능하다.
$ rmdir [대상 디렉토리]

# 여러개 삭제
$ rmdir [디렉토리명1] [디렉토리명2] [디렉토리명3]

# 디렉토리 및 하위디렉토리를 같이 삭제. 단, 부모 디렉토리가 비었을 경우
$ rmdir -p 파일명/하위디렉토리

# 디렉터리 삭제 (디렉터리는 -r 옵션 없이 삭제 불가)
# 디렉토리 안에 파일이 있어도 강제 삭제!!
$ rm -r [대상 디렉토리]
```
<br/><br/><br/>

### 파일 문자 수 세기

- wc (****파일 내용 정보 출력****)

→ 지정한 파일에 대해 단어, 개행문자, 문자의 개수 등을 출력

→ 옵션 생략 시 줄, 단어, Bytes 수를 기본으로 출력

```bash
$ wc [option] file
# -l,--lines : 줄수를 셈
# -w,--words : 단어의 개수를 셈
# -c,--bytes : 바이트 수를 셈
# -L,--max-line-length : 가장 긴줄의 길이를 출력
```
<br/><br/><br/>
## 2. 파일 다루기

### (1)파일 필터

파일의 내용 중 원하는 부분을 검색하거나 파일에 내용을 쓰거나 출력, 기존 파일에 추가하여 내용 쓸 수 있는데, 이는 파일 필터를 활용한 것

### 파이프(|)

 명령 1 I 명령 : （파이프) 어떤 명령의 결과를 받아 다른 명령을 실행

### grep (****파일 패턴 검색****)

→ 텍스트 파일을 한 줄 씩 읽어서 지정한 패턴과 일치하는 문자열 보여주는 명령어
<br/><br/><br/>
### 리다이렉션

### (2) 파일 비교 / 정렬 / 탐색

### 파일 비교

- cmp (****파일 비교****)

→ 두 파일이 다르면, 내용이 달라지기 시작하는 위치(문자수나 줄수) 출력

→ 완벽히 두개가 같으면 no 출력

| 옵션 | 설명 |
| --- | --- |
| -b | 두 파일간의 다른 바이트들을 출력 |
| -i | 입력어의 최초 SKIP 바이트들을 건너뛴다. |
| -l | 틀린 문자의 갯수를 출력 |
| -s | 아무것도 출력하지 않고 종료 코드만을 출력
0:파일이 같음, 1:파일이 다름, 2:파일에 접근 불가 |
| -v | 버전 정보 출력 |

- diff (****파일 비교****)

```bash
$ diff [파일1] [파일2]

$ diff3 [파일1] [파일2] [파일3] # 3개 파일 비교가 가능하다
```
<br/><br/><br/>
### 파일 정렬

- sort (****파일 내용 정렬****)

→ 정렬 기준인 필드를 선택하여 오름차순이나 내림차순으로 전체 줄을 순서대로정렬
→ 필드 기준은 빈칸을 기준으로 수행

```bash
$ sort [옵션] [파일명] 
# -r: 역순(내림차순) 정렬 / 기본은 오름차순
# -f: 대소문자 구별안함
# -n: 숫자로 정렬
# -k숫자: k1 -> 1번째 필드를 기준으로 정렬
# -u: 정렬 후 중복된 내용을 제거

# -b: 선행 공백 무시
# -R: 해시의 키값 기준, 랜덤 정렬
# -h: --human(2K, 1G)
# -c: 정렬되어 있는지 검사
# -m: 이미 정렬된 파일들을 병합
# -o: 파일출력
# -t: 필드 구분자를 지정
```

```bash
# sort 명령어를 사용하면 오름차순으로 정렬된다.
$ sort sort.txt

# 다음과 같이 cat 명령어를 통해 파일을 열고 파이프를 통해 sort 명령어를 사용해도 된다.
# 위와 같은 결과 출력
$ cat sort.txt | sort

# -r 옵션으로 역순으로 정렬
$ sort -r sort.txt
$ cat sort.txt | sort -r

# -u 옵션으로 정렬 후 중복값 제거
$ sort -u sort3.txt

# -f 옵션으로 대소문자 구분 없이 정렬
# 대문자가 먼저 앞으로 온다
$ sort -f  sort5.txt

# 파일이 정렬되어 있는지 검사
$ cat /etc/passwd | sort -c

# 정렬 후 파일로 저장
$ sort /etc/passwd -o output.txt
```
<br/><br/><br/>
### 파일 검색

- find (****파일/디렉토리 검색****)

→ 원하는 조건의 파일의 위치를 찾아줌

```bash
$ find [경로] [옵션] [표현식]
$ find [PATH] [OPTION] [EXPRESSION]
```
<br/><br/><br/>

### (3) 파일 보관, 압축

- tar: 파일을 보관하거나 푸는 명령어

→ 일반적 기능: 파일을 묶고 푸는 기능으로 압축 기능은 없음 / 파일을 묶어 테이프로 저장 등에 사용

→ 파일을 묶을 때: tar -cvf tarFileName fileList

→ 묶은 파일을 풀 때: tar -txru tarFileName fileList

- -t: tar 형식의 백업 파일 안에 어떤 것들이 들어 있는지 차례만 보임
- -x: 백업 파일로부터 파일을 추출 복귀 (extra)
- - r: fileList를 기존의 백업 파일 뒤에 무조건 덧붙임
- - u: 기존의 백업 파일에 이미 포함되어 있는 file List 중 수정된 파일들만
을 백업 파일의 뒤에 덧붙임

- compress/uncompress (파일을 압축하고 푸는 명령어)

→ 압축하는 경우 compress 로 명령하면 a b c 파일이 압축되어 abc.z의 해당 이름의 .z 확장자가 붙은 압축 파일이 생성됨 .
→ 압축을 푸는 경우 uncompress 로  abc.z로 명령하면 abc.z 파일이 압축이 풀려서 abc로 복원된 파일이 생성됨.
→ 파일을 묶어서 압축히는 기능은 gzip, gunzip 명령어를 많이 사용하는데, 이는 개인용 PC에서 많이 쓰는 ZIP 압축 방식

- gzip / gunzip

→ 

gzip과 gunzip은 리눅스와 유닉스 시스템에서 파일 압축 및 압축 해제를 위한 명령어입니다.

gzip은 파일을 압축하여 더 작은 크기로 만들어주는 프로그램입니다. 압축된 파일은 .gz 확장자를 가집니다. gzip은 다른 프로그램과 함께 사용할 수 있도록 입력을 받아서 출력으로 압축된 데이터를 생성하거나, 반대로 입력으로 압축된 데이터를 받아서 출력으로 압축을 해제한 원래 파일을 생성할 수 있습니다.