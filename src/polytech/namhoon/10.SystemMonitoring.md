---
layout : home
---



# 시스템 모니터링



### 【시스템 모니터링의 목적】



**1) 시스템의 빠른 장애 탐지 :** 모니터링의 가장 기본적인 목적은 시스템의 상태를 빠르게 파악하는 것이다. 이때는 사전또는 사후 관리를 위한 지표를 설정하고 빠르게 상태를 감지하는 것이 중요하다. 



**2) 서비스의 다운타임의 최소화 :** 빠른 장애 탐지를 통해 획득한 다양한 정보와 통계정보를 통해 서비스 복원을 수행하는 것이다. 이때  다양한 데이터 수집과 쉽게 상태 파악이 가능한 Dash Board나 검색 기능이 필요하다.



**3) 의사결정에 도움을 주는 것 :** 현재 상태에 대한 정보를 쉽게 파악하도록 시각화해 제공하고, 수집된 데이터의 의미를 파악하고 올바른 기준을 설정하도록 하여야 한다. 데이터는 단순한 장애 모니터링 뿐아니라 시스템의 증설이나 성능개선을 전.후를 파악하여 올바른 방향을 수립하도록 해야 한다.



**4) 운영 자동화 :** 운영 자동화란 장애가 발생했을 때 알림이나 장애 처리를 위한 룰을 적용해서 빠르게 상황에 대처하도록 서비스 복원을 자동화하기 위한 것이다. 특히 클라우드 같은 시스템을 자동 증설이나 축소를 자동화하여 시스템의 성능과 비용을 최적화 한다. 최근에는 인공지능 기술을 활용하여 시스템의 장애나 위협 상황을 사전 감지하는 것도 가능하다.



![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc2fybY%2FbtqPfSrA0HE%2FgzXtHNcpmMX1JUNYFsUPK1%2Fimg.jpg)





## 명령어를 통한 시스템 측정

리눅스 운영체제에서 시스템 측정(System monitoring)은 시스템 자원(CPU, 메모리, 디스크 등)의 사용률과 성능, 네트워크 연결 상태 등의 정보를 지속적으로 수집하여 분석하는 작업을 말합니다. 시스템 측정을 통해 시스템의 안정성, 성능, 문제점 등을 파악하여 문제점을 해결하고 최적화된 시스템 운영을 할 수 있습니다.

대표적인 시스템 측정 도구로는 top, vmstat, iostat, netstat, sar 등이 있습니다.



## 1.**Top** : <u>현재</u> CPU에 수행되고 있는 프로세스 상황을 CPU 자원을 많이 사용하는 순서대로 보여줌

시스템 전반적인 값(CPU/메모리)을 쉽게 확인할 수 있음

다만, 화면이 지속적으로 바뀜 (디폴트 업데이트시간 : 3초)

ps는 현 시점에 대한 프로세스 모니터링, top은 실시간 모니터링

 

## **실행 후 옵션**

| **Shift + p** | **CPU 사용률(%CPU) 큰 순서로 정렬**             |
| ------------- | ----------------------------------------------- |
| **Shift + m** | **메모리 사용률(%MEM) 큰 순서로 정렬**          |
| Shift + t     | 실행시간이 큰 순서로 정렬                       |
| K             | process 종료  이후 -9 죽일 프로세스ID(PID) 입력 |

## **해석**

![img](https://k.kakaocdn.net/dn/xyX6g/btqD2bJJdhy/2ClFbxQrOLGszym8FRH5PK/img.png)

 

현재 서버시간 / user 수 / 부하율

task 정보

| Top          | 현재 서버의 시간                                             |
| ------------ | ------------------------------------------------------------ |
| User         | 2 users : 2명의 사용자가 접속                                |
| Load average | 부하율 **1분, 5분, 15분 간의 평균 실행/대기 중인 프로세스의 수** |
| Task         | 전체 가동 중인 프로세스 개수 Running : 실행중인 프로세스 Sleeping : 대기중인 프로세스  Stopped : 멈춘 프레세스 Zombie : 좀비상태인 프로세스 |

CPU 정보

| %us  | 유저 레벨에서 사용하는cpu비중                                |
| ---- | ------------------------------------------------------------ |
| %sy  | 시스템 레벨애서 사용하는 cpu비중                             |
| %id  | 유휴상태의 cpu비중                                           |
| %wa  | 시스템 io 요청을 처리하지 못한 상태에서 cpu idle 상태인 비중 |

메모리 정보

| Total      | 전체 물리적인 메모리     |
| ---------- | ------------------------ |
| Free       | 사용되지 않은 여유메모리 |
| Used       | 사용중인 메모리          |
| Buff/cache | 버퍼된 메모리            |

프로세스정보

| PID     | 프로세스ID                                                   |
| ------- | ------------------------------------------------------------ |
| USER    | 프로세스를 실행시킨 사용자ID                                 |
| NI      | NICE값(마이너스면 우선순위높은 일)                           |
| S       | 프로세스의 상태 S : sleeping R : Running W : swapped out process z : zombies |
| %CPU    | 프로세스가 사용하는 CPU의 사용률                             |
| %MEM    | 프로세스가 사용하는 메모리의 사용률                          |
| COMMAND | 실행된 명령어                                                |



# 2. vmstat : 가상 메모리 통계 정보 확인( CPU / 메모리 / IO)현재 메모의 상태 출력

시스템 전반적인 값(CPU/메모리/IO)을 top보다 요약된 정보로 쉽게 확인할 수 있음

 

## **옵션**

| -a (active)       | buffer와 cache대신 active/inactivate로 메모리사용량 결과 출력 |
| ----------------- | ------------------------------------------------------------ |
| -t (timestamp)    | 날짜 + 시간을 출력                                           |
| -w (wide)         | 출력결과의 너비를 맞춤                                       |
| -d (disk)         | 디스크 상태조회                                              |
| [간격] [반복횟수] | vmstat 2 5 : 2초간격으로 5번 출력                            |

 

## 해석



![img](https://blog.kakaocdn.net/dn/mofSb/btqD1Ohkkxb/oRlpkYGQPoTyObcKOCYcTK/img.png)1초 간격으로 출력



**procs 필드**

| r (run)   | 현재 실행중인 프로세스 중 (cpu에 접근대기중인 프로세스) |
| --------- | ------------------------------------------------------- |
| b (block) | io자원을 할당받지 못해서 블록된 프로세스 수             |

**memory필드**

| swpd  | 사용된 가상 메모리 용량         |
| ----- | ------------------------------- |
| free  | 사용가능한 여유메모리 용량      |
| buff  | 버퍼에 사용된 메모리 용량       |
| cache | 페이지캐시에 사용된 메모리 용량 |

**swap 필드**

| si (swap-in)  | swap-in 된 메모리양                                          |
| ------------- | ------------------------------------------------------------ |
| so (swap-out) | swap-out 된 메모리양 ***(지속적으로 발생하면 메모리 부족)\*** |

**io 필드**

| bi (block input)  | 블록 디바이스로부터 입력된 블록수 |
| ----------------- | --------------------------------- |
| bo (block output) | 블록 디바이스로부터 쓰기된 블록수 |

**system 필드**

| in (interrupts)       | 초당 발생할 interrupts의 수              |
| --------------------- | ---------------------------------------- |
| cs (context switches) | 초당 발생한 context switchs(문맥교환) 수 |

**CPU필드** 

| us (user)   | CPU가 user level의 코드를 실행한 시간(단위%) -> 사용자 영역에서 사용하는 CPU의 비율 *us의 CPU가 높을 경우 : OS명령어로 알기 어렵다.* |
| ----------- | ------------------------------------------------------------ |
| sy (system) | CPU가 system level의 코드를 실행한 시간(단위%) -> 시스템콜 호출에 의해 사용되는 CPU비율 *sy의 CPU가 높을 경우 : truss 명령어로 어떤 시스템 콜이 수행중인지 확인가능* |
| id (idel)   | 사용가능한 CPU의 시간율 id = 100 - (us+sy)                   |
| wa (wait)   | 디스크 혹은 기타 io작업으로 인해 CPU가 대기하는 시간비율     |

 

## 예시

**1. [간격]으로 [횟수] 만큼 출력 : vmstat 2 5**



![img](https://blog.kakaocdn.net/dn/n8wxy/btqD1q8RGYT/zFk5kSgKL3rsxRfbosppiK/img.png)2초 간격으로 5개만 출력



**2. active/inactivate로 표시 : vmstat -a**



![img](https://blog.kakaocdn.net/dn/QD2Kv/btqD0Mj2t5d/lyGlqZDWSvbeKSLFoMmqqK/img.png)



active : 사용 중인 메모리양

inact : 사용되지 않은 메모리 양

 

**3. 시간까지 표시해서 출력 : vmstat -t**



![img](https://blog.kakaocdn.net/dn/cGQ5PK/btqD1N3O76a/Ltyn9rpCDVxdmwLE3xPQB1/img.png)



**4. 디스크 사용량 : vmstat -d** 



![img](https://blog.kakaocdn.net/dn/b1xv1o/btqD4TBiWCE/kUp4VFhn9SGfC0K6l82n01/img.png)



디스크명 : xvda

reads 필드 / wirtes 필드

| total   | 성공한 모든 읽기/쓰기 작업개수              |
| ------- | ------------------------------------------- |
| merged  | 하나의 io로 묶은 읽기/쓰기 작업수           |
| sectors | 성공적으로 읽은/쓴 섹터수                   |
| ms      | 읽기/쓰기 작업을 하는데 소요된 시간(밀리초) |

io필드

| cur  | 현재 수행중인 io수              |
| ---- | ------------------------------- |
| sec  | io를 수행하는데 소요된 시간(초) |

 

**3) mpstat**

CPU time을 CPU별로 측정
CPU별로 불균형한 상태 확인



![img](https://blog.kakaocdn.net/dn/qmUTz/btqDvZX6vdQ/suqvkbDlJ069PKbASMK1cK/img.png)



**4) pidstat
**

TOP이랑 비슷하지만 지속적으로 변화하는 상황



![img](https://blog.kakaocdn.net/dn/bUzUff/btqDvxVaP7f/J4TYXRF89Lr3je2aMepzJ0/img.png)



**5) sar (Systemc Activity Reprot)**



![img](https://blog.kakaocdn.net/dn/4lvTd/btqDwdWcFll/qNIvoJVel9iFHLWfLMVSAK/img.png)



 

 

**+kill 명령어**

프로세스 종료 명령어

사용포맷 : kill [옵션명 or 옵션번호] PID

그 중에서

옵션번호 9 : 프로세스 죽이기 (SIGKILL)

옵션번호 15 : 소프트웨어 안전종료(SIGTERM)

ex) 

kill -9 PID : 프로세스 번호로 강제종료 --> 작업중인 모든 데이터를 저장하지 않고 종료

kill -15 PID : 프로세스 번호로 안전종료 --> 메모리상에 있는 데이터 저장한 후 종료



# 3. iostat : 디스크 입출력 모니터링

iostat 명령은 CPU의 상태와 디스크 입출력에 대한 정보를 모니터링 합니다. iostat 명령으로 물리적 디스크 간의 입/출력 균형을 더 잘 맞추기 위해 시스템 구성을 변경하는 데 사용할 수 있는 보고서를 생성합니다. 시스템의 과부하나 문제를 확인하기 위해 사용 됩니다.

 

아무 옵션 없이 iostat을 입력하면 CPU와 디스크 입출력에 대한 통계를 아래와 같이 동시에 볼 수 있습니다. 

 



![img](https://blog.kakaocdn.net/dn/EBHXw/btraGcxPO9W/kBW4XBlNtmdH4RXk1ifHpk/img.png)



 

#### **CPU 관련 정보**

|             | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| **%user**   | **Application 같은 user level에서의 CPU 사용량**             |
| **%nice**   | **Nice 우선순위를 갖는 Application (user level)의 CPU 사용량** |
| **%system** | **Kernel 같은 System level에서의 CPU 사용량**                |
| **%iowait** | **미해결 I/O 작업이 완료되기를 기다리는 동안 CPU가 소비한 시간. I/O 완료를 기다리는 시간.**  **해당 CPU가 IDLE 상태(즉, 작업을 실행하지 않음)이고 해당 CPU에 예약된 작업에서 요청한 미해결 디스크 I/O 작업이 최소한 하나 있었던 시간 ( 해당 I/O 요청을 생성할 때).**  **참조 : https://veithen.io/2013/11/18/iowait-linux.html** |
| **%steal**  | **하이퍼바이저가 다른 가상 프로세서에 서비스를 제공하는 동안 가상 CPU가 비자발적으로 대기한 시간의 백분율** |
| **%idle**   | **CPU가 유휴 상태이고 시스템에 처리되지 않은 디스크 I/O 요청이 없는 시간의 백분율** |

 

#### **디스크 입출력에 대한 정보**

|                    | **설명**                                                     |
| ------------------ | ------------------------------------------------------------ |
| **device**         | **/dev 디렉토리에 나열된 장치(또는 파티션)들**               |
| **tps**            | **transfers per seconds. 초당 전송 (장치에 대한 IO 요청)률. 여러 논리적 요청을 장치에 대한 단일 I/O 요청으로 결합할 수 있음. 전송 크기가 불확실함.** |
| **KB_read/s**      | **장치에서 읽은 데이터의 양을 초당 블록 수(kilobytes, megabytes)로 표시. 블록은 섹터와 동일하므로 크기가 512바이트임.** |
| **KB_wrtn/s**      | **장치에 기록된 데이터의 양을 초당 블록 수(kilobytes, megabytes)로 계산하여 표시** |
| **KB_read**        | **읽은 총 블록 수(kilobytes, megabytes)**                    |
| **KB_wrtn**        | **기록한 총 블록 수 (\**kilobytes, megabytes)\****           |
| ***\*%util\****    | **/proc/diskstats filed #10) 장치에 I/O 요청이 발행된 CPU 시간의 백분율(장치의 대역폭 사용률). 이 값이 100%에 가까울 때 장치 포화가 발생합니다.  Percentage of CPU time during which I/O requests were issued to the device (bandwidth utilization for the device). Device saturation occurs when this value is close to 100%.** |
| ***\*await\****    | ***\*/proc/diskstats filed #4)\** 처리할 장치에 발행된 I/O 요청의 평균 시간(밀리초)입니다. 여기에는 대기열의 요청에 소요된 시간과 해당 요청을 처리하는 데 소요된 시간이 포함됩니다.  The average time (in milliseconds) for I/O requests issued to the device to be served. This includes the time spent by the requests in queue and the time spent servicing them.** |
| ***\*avgrq-sz\**** | **장치에 발행된 요청의 평균 크기(섹터)입니다 The average size (in sectors) of the requests that were issued to the device.** |
| ***\*avgqu-sz\**** | ***\*/proc/diskstats filed #11\** 장치에 발행된 요청의 평균 대기열 길이입니다. The average queue length of the requests that were issued to the device.** |

 

 

 

#### **옵션들**

| **명령**                                                     |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **-c**                                                       | ***\*CPU 사용량 통계  \****![img](https://blog.kakaocdn.net/dn/sxHHO/btra33zDe2D/7CiSerXTs8ocV1lER8MTI1/img.png) |
| **-d**                                                       | ***\*디스크 IO 통계  \****![img](https://blog.kakaocdn.net/dn/cdlEPf/btraVFS54Yt/MUb95NrnFxwyPaFWTz3rI1/img.png) |
| **-g group_name ( device [...] \| ALL }**                    | **장치 그룹에 대한 통계를 표시합니다. iostat 명령은 목록의 각 개별 장치에 대한 통계를 보고한 다음 group_name으로 표시되고 목록의 모든 장치로 구성된 그룹에 대한 전역 통계 행을 보고합니다. ALL 키워드는 시스템에서 정의한 모든 블록 장치가 그룹에 포함되어야 함을 의미합니다.  Display statistics for a group of devices. The iostat** **command reports statistics for each individual device in** **the list then a line of global statistics for the group** **displayed as group_name and made up of all the devices in** **the list. The ALL keyword means that all the block devices** **defined by the system shall be included in the group.** |
| **-H**                                                       | **이 옵션은 -g 옵션과 함께 사용해야 하며 그룹의 개별 장치에 대한 통계가 아니라 그룹에 대한 전역 통계만 표시됨을 나타냅니다.  This option must be used with option -g and indicates that** **only global statistics for the group are to be displayed,** **and not statistics for individual devices in the group.** |
| **-h**                                                       | ***\*--human 과 동일  \****![img](https://blog.kakaocdn.net/dn/coWUDJ/btraP82NfA4/7VSQZe04ipxsOgg5mdK670/img.png) |
| **--human**                                                  | **사람이 읽을 수 있는 형식의 인쇄 크기(예: 1.0k, 1.2M 등) 이 옵션으로 표시되는 단위는 메트릭과 관련된 다른 기본 단위(예: 킬로바이트, 섹터...)를 대체합니다.  Print sizes in human readable format (e.g. 1.0k, 1.2M,** **etc.) The units displayed with this option supersede any** **other default units (e.g. kilobytes, sectors...)** ***\*associated with the metrics.  \****![img](https://blog.kakaocdn.net/dn/blbT7T/btraZNcb4sR/w1IUlXbVKPKBUqkYRa5pg1/img.png) |
| **-j { ID \| LABEL \| PATH \| UUID \| ... } [device [...] \| ALL ]** | **영구 장치 이름을 표시합니다. 키워드 ID, LABEL 등은 영구 이름의 유형을 지정합니다. 이러한 키워드는 제한되지 않으며 필수 영구 이름이 있는 디렉토리가 /dev/disk에 있어야 한다는 전제 조건만 있습니다. 선택적으로 선택한 영구 이름 유형에 여러 장치를 지정할 수 있습니다.   Display persistent device names. Keywords ID, LABEL, etc.** **specify the type of the persistent name. These keywords a****re not limited, only prerequisite is that directory with** **required persistent names is present in /dev/disk.** **Optionally, multiple devices can be specified in the** **chosen persistent name type.** |
| **-k**                                                       | ***\*초당 킬로바이트 단위로 통계를 표시합니다. Display statistics in kilobytes per second.  \****![img](https://blog.kakaocdn.net/dn/mwOcm/btraVTEgr4S/NeoL9RZR4n1YkCufFuDkd1/img.png) |
| **-m**                                                       | ***\*초당 메가바이트 단위로 통계를 표시합니다 Display statistics in megabytes per second.  \****![img](https://blog.kakaocdn.net/dn/dMgTt4/btra34R0Tud/pThOsW9ESoxJrf4Zis9YPK/img.png) |
| **-N**                                                       | **모든 장치 매퍼 장치에 대해 등록된 장치 매퍼 이름을 표시합니다. LVM2 통계를 보는 데 유용합니다. Display the registered device mapper names for any device** **mapper devices. Useful for viewing LVM2 statistics.** |
| **-o JSON**                                                  | **통계를 JSON(Javascript Object Notation) 형식으로 표시합니다. JSON 출력 필드 순서는 정의되지 않았으며 향후 새 필드가 추가될 수 있습니다.  Display the statistics in JSON (Javascript Object Notation) format. JSON output field order is undefined, and new fields may be added in the future.** |
| **-p [ ( device [...] \| ALL } ]**                           | **시스템에서 사용하는 블록 장치 및 모든 해당 파티션에 대한 통계를 표시합니다. 명령줄에 장치 이름을 입력하면 해당 장치와 모든 파티션에 대한 통계가 표시됩니다. 마지막으로 ALL 키워드는 사용된 적이 없는 것을 포함하여 시스템에서 정의한 모든 블록 장치 및 파티션에 대한 통계가 표시되어야 함을 나타냅니다. 이 옵션 앞에 -j 옵션이 정의되어 있으면 명령줄에 입력한 장치를 선택한 영구 이름 유형으로 지정할 수 있습니다.  Display statistics for block devices and all their partitions that are used by the system. If a device name is entered on the command line, then statistics for it and all its partitions are displayed. Last, the ALL keyword indicates that statistics have to be displayed for all the block devices and partitions defined by the system, including those that have never been used. If option -j is defined before this option, devices entered on the command line can be specified with the chosen persistent name type.** |
| **-s**                                                       | ***\*80자 너비의 화면에 맞는 짧은(좁은) 버전의 보고서를 표시합니다. Display a short (narrow) version of the report that should fit in 80 characters wide screens.  \****![img](https://blog.kakaocdn.net/dn/XTT1s/btra6I2fRdh/1ohLNoUAqUyWwhMoxx4g8K/img.png) |
| **-t**                                                       | ***\*표시된 각 보고서의 시간을 인쇄합니다. 타임스탬프 형식은 S_TIME_FORMAT 환경 변수의 값에 따라 달라질 수 있습니다. Print the time for each report displayed. The timestamp format may depend on the value of the S_TIME_FORMAT environment variable.  \****![img](https://blog.kakaocdn.net/dn/Oc034/btra8nKjS0w/h6WValIT7XLHV5kdav6s51/img.png) |
| **-V**                                                       | **Print version number then exit.**                          |
| **-x**                                                       | ***\*확장 통계를 표시합니다. Display extended statistics.  \****![img](https://blog.kakaocdn.net/dn/bLSG6D/btra10oPYxZ/Oic84t5oeEBsG0FMZQmRP1/img.png) |
| **-y**                                                       | **지정된 간격으로 여러 레코드를 표시하는 경우 시스템 부팅 이후 통계가 포함된 첫 번째 보고서를 생략합니다. Omit first report with statistics since system boot, if displaying multiple records at given interval.** |
| **-z**                                                       | **샘플 기간 동안 활동이 없었던 모든 장치에 대한 출력을 생략하도록 iostat에 지시합니다. Tell iostat to omit output for any devices for which there was no activity during the sample period.** |

 

 

연관된 환경변수

| 환경변수            | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| **POSIXLY_CORRECT** | **이 변수가 설정되면 전송 속도는 기본 1K 블록 대신 512바이트 블록으로 표시됩니다. When this variable is set, transfer rates are shown in** **512-byte blocks instead of the default 1K blocks.** |
| **S_COLOR**         | **기본적으로 통계는 출력이 터미널에 연결될 때 컬러로 표시됩니다. 이 변수를 사용하여 설정을 변경합니다. 이 변수에 가능한 값은 never, always 또는 auto입니다(후자는 기본 설정과 동일함).  값을 표시하는 데 사용된 색상(빨간색, 노란색 또는 기타 색상)은 단순히 색상 때문에 어떤 종류의 문제도 나타내지 않습니다. 다른 값 범위만 나타냅니다.  By default statistics are displayed in color when the** **output is connected to a terminal. Use this variable to** **change the settings. Possible values for this variable are** **never, always or auto (the latter is equivalent to the** **default settings).** ** Please note that the color (being red, yellow, or some** **other color) used to display a value is not indicative of** **any kind of issue simply because of the color. It only** **indicates different ranges of values.** |
| **S_COLOR_SGB**     | **터미널에 통계를 표시하는 데 사용되는 색상 및 기타 속성을 지정합니다. 그 값은 H=31;1:I=32;22:M=35;1:N=34;1:Z=34;22로 기본 설정되는 기능의 콜론으로 구분된 목록입니다. 지원되는 기능은 다음과 같습니다.   H= 75% 이상의 백분율 값에 대한 SGR(Select Graphic Rendition) 하위 문자열.   I= 장치 이름에 대한 SGR 하위 문자열.  M= 50% ~ 75% 범위의 백분율 값에 대한 SGR 하위 문자열.  N= 0이 아닌 통계 값에 대한 SGR 하위 문자열.  Z= 0 값에 대한 SGR 하위 문자열.  Specify the colors and other attributes used to display** **statistics on the terminal. Its value is a colon-** **separated list of capabilities that defaults to** **H=31;1:I=32;22:M=35;1:N=34;1:Z=34;22. Supported** **capabilities are:**   **H=   SGR (Select Graphic Rendition) substring for** **percentage values greater than or equal to 75%.**  **I=   SGR substring for device names.**  **M=   SGR substring for percentage values in the range** **from 50% to 75%.**  **N=   SGR substring for non-zero statistics values.**  **Z=   SGR substring for zero values.** |
| **S_TIME_FORMAT**   | **이 변수가 존재하고 그 값이 ISO이면 보고서 헤더의 날짜를 인쇄할 때 zcurrent 로케일이 무시됩니다. iostat 명령은 대신 ISO 8601 형식(YYYY-MM-DD)을 사용합니다. -t 옵션으로 표시되는 타임스탬프는 ISO 8601 형식도 준수합니다.  If this variable exists and its value is ISO then the** **zcurrent locale will be ignored when printing the date in** **the report header. The iostat command will use the ISO** **8601 format (YYYY-MM-DD) instead. The timestamp displayed** **with option -t will also be compliant with ISO 8601** **format.** |

 

------

#### **사용예**

**iostat :** Display a single history since boot report for all CPU and Devices.

**iostat -d 2 :** Display a continuous device report at two second intervals.

**iostat -d 2 6 :** Display six reports at two second intervals for all devices.

**iostat -x hda hdb 2 6 :** Display six reports of extended statistics at two second intervals for devices hda and hdb.

**iostat -p sda 2 6 :** Display six reports at two second intervals for device sda and all its partitions (sda1, etc.)

 

**iostat [ -c ] [ -d ] [ -N ] [ -n ] [ -h ] [ -k | -m ] [ -t ] [ -V ] [ -x ] [ -z ] [** *device* **[...] | ALL ] [ -p [** *device* **[,...] | ALL ] ] [** *interval* **[** *count* **] ]**





# 4. netstat : 네트워크 상태 모니터링

네트워크 관련 정보를 보는데 일반적으로 사용하는 범용 유틸리티입니다

 ***tcp / udp / 소켓의 네트워크 연결 목록을 확인할 때 주로 사용합니다.***

------

*** netstat -a ( -a 옵션을 주어서 모든 연결 목록을 출력합니다 )**

 



![img](https://blog.kakaocdn.net/dn/dwmSN7/btqvJKNBSW9/agO4MQRsTXZPlodL95Onl1/img.png)

![img](https://blog.kakaocdn.net/dn/VETf6/btqvImzIam0/t5OXkAC2ocxgeXMqYqxOk0/img.png)



뭐라고 뭐라고 막 많이 출력되었습니다.

해당하는 필드가 의미하는 것이 무엇인지 파악이 필요하겠죠? 뭐든지 알기 전까진 어렵지만 알고 나면 쉽습니다.

알아봅시다.

 

| 필 드 명            | 의 미                                                        |
| ------------------- | ------------------------------------------------------------ |
| **Proto**           | 사용중인 프로토콜을 표시해주는 필드입니다. ( ex. tcp/udp )   |
| **Recv-Q**          | 수신 소켓 버퍼에 존재하는 바이트 수를 표시해주는 필드입니다. |
| **Send-Q**          | 송신 소켓 버퍼에 존재하는 바이트 수를 표시해주는 필드이며  반대편 peer socket에 전송되지 못한 것을 의미합니다. |
| **Local Address**   | 로컬 주소 표시 필드                                          |
| **Foreign Address** | 상대편 주소 표시 필드                                        |
| **state**           | 현재 연결의 상태를 표시해 주는 필드입니다.                   |

 

 

 

*** netstat -nr ( -nr 옵션을 주어서 라우팅 테이블 상태를 출력합니다.)**

 



![img](https://blog.kakaocdn.net/dn/uvP5c/btqvJUid9oy/wKPaVvZRZJowqwkTjkKkFK/img.png)



route 명령어를 사용했을 때와 동일한 결과를 출력해줍니다.

기본적으로 -r 옵션만 주어서 출력을 할 수 있지만 -n 옵션을 주어서 호스트 찾기 안 함으로 빠른 결과를 출력할 때

사용합니다.

 

여기서 의미하는 필드의 값도 알아봅시다.

 

| 필 드 명    | 의 미                                                        |
| ----------- | ------------------------------------------------------------ |
| **Gateway** | 라우팅 항목에서의 gateway를 표시합니다.                      |
| **Genmask** | 라우팅 항목의 netmask 를 표시합니다.                         |
| **Flags**   | 라우팅 경로에 관한 여러 플래그를 표시합니다. **U** : 인터페이스가 UP 인 상태 **H** : 라우팅 경로를 통해 호스트로의 연결 **G** : 게이트웨이의 라우트 **D** : 라우트가 재지정되어 동적으로 생성 **M** : 라우팅 경로가 ICMP 리다이렉트 메시지를 통해 수정되었을 경우   최대 세크먼트 크기 |
|             |                                                              |
| **MSS**     |                                                              |
| **Window**  | 원격에서 한 번에 보내는 데이터의 수신량                      |
| **irtt**    | initial round trip time 으로, 0은 초기 설정값을 사용한다는 의미 |
| **Ifce**    | 네트워크 인터페이스                                          |

 

 

 

*** netstat -at ( -at 옵션을 부여하여 tcp 연결만 모두 출력할 때 사용합니다. )**

 



![img](https://blog.kakaocdn.net/dn/DvsCN/btqvJ5X9unY/Yc2uu22Xh2WLv2WvSnd5CK/img.png)



다음과 같이 tcp 연결의 모든 상태를 출력합니다.

 

*** netstat -au ( -au 옵션을 부여하여 udp 연결만 모두 출력할 때 사용합니다. )**

 



![img](https://blog.kakaocdn.net/dn/3B2Pc/btqvIlt7S8i/GiUgI3pM5TzfpcMXrymWnK/img.png)



tcp와 반대로 udp 연결의 모든 상태를 출력합니다.

해당 필드 값은 위에 참고해주세요.

 

*** netstat -nl ( -nl 옵션을 부여하여 호스트 찾기 안 함으로 빠르게 Linsten 인 상태 모두를 출력할 때 사용 )**

 



![img](https://blog.kakaocdn.net/dn/copwRz/btqvIkvc6qt/zDwkFLtkF7UldeVYCTyJGK/img.png)



여기서 응용하면 -t 옵션을 추가하여 -ntl 옵션으로 tcp의 Linsten 인 상태 모두를 출력할 수도 있습니다.

반대로 -u 옵션을 추가하여 -nul 옵션으로 udp의 Listen 인 상태 모두를 출력도 가능합니다.

 

여기서 상태를 나타내는 **state의** 필드 값에 대해서 알아봅시다.

| 필 드 값                                | 의 미                                                        |
| --------------------------------------- | ------------------------------------------------------------ |
| **LISTEN**                              | 연결이 가능하도록 관련 데몬이 떠있으며 연결이 가능함을 의미합니다. |
| **SYN-SENT**                            | 연결을 요청한 상태를 의미합니다.                             |
| **SYN_RECEIVED**                        | 연결요구에 의한 응답을 준 후에 확인메시지를 기다리고 있는 상태를 의미. |
| **ESTABLISHED**                         | 위의 3단계 연결과정이 모두 종료된 후에 연결이 완료된 상태를 의미. |
| **FIN-WAIT, CLOSE-WAIT,** **FIN-WAIT2** | 연결 종료를 위해 종료 요청을 받은 후의 종료 과정을 의미.     |
| **CLOSING**                             | 전송된 메시지가 유실된 상태를 의미합니다.                    |
| **TIME-WAIT**                           | 연결종료 후에 한동안 유지하고 있는 상태를 의미합니다.        |
| **CLOSED**                              | 연결이 완전히 종료된 상태를 의미합니다.                      |

state의 해당 필드 값이 의미하는 뜻이 무엇이지 파악하고 있는 것이 troubleshooting 할 때 굉장히 중요한 부분이니 꼭 체크하고 넘어가시기 바랍니다.



# 5. sar : CPU 사용률, 메모리 사용률, 디스크 I/O 및 네트워크 트래픽과 같은 리눅스 시스템의 성능 지표를 일정한 시간 간격으로 수집합니다. 

\- 기본적으로 sar 명령어를 입력하였을 경우 보여지는 값은 CPU사용 정보입니다.
  \* %user : user mode 에서 작동한 CPU 가동률
  \* %sys : kernel mode에서 작동한 CPU 가동률
  \* %idle : idle 상태로 있었던 CPU 대기율
  \* %iowait : io wait 상태로 있었던 CPU 대기율

\- 실시간으로 정보 보기는 "sar [간격] [인터벌] 형식으로 입력합니다.
 ex) sar 3 10 : 3초 간격으로 10개의 데이터 값을 출력해 줍니다. 

\- 특정 날짜의 sar 정보 확인은 아래 명령어로 확인 가능합니다. (1달치 정보 조회 가능)
  해당 옵션은 다른 옵션과 조합하여 CPU 사용 정보 이외의 정보 조회도 가능합니다. 
  ex) sar -f /var/log/sa/sa01   -> 1일자 CPU 사용 정보 정보 출력

#### **[옵션 활용을 통한 시스템 모니터링]**

**-b** : 버퍼의 액티비티 측정. I/O와 transfer의 통계를 백분율로 출력합니다.
   \* tps : 디스크에서 발생되어진 초당 전송량. 즉 디스크에 요청한 I/O양.
   \* rtps : 디스크로부터 발생된 초당 읽기 총 요청 횟수
   \* bread/s : 드라이브 안의 블럭에서 초당 읽은 데이터의 총합.
   \* bwrtn/s : 드라이브 안의 블럭에서 초당 쓰여진 데이터의 총합.
![sar-b.JPG](https://cafe24.zendesk.com/hc/article_attachments/10070655918489/sar-b.JPG)

**-q** : 실행 대기 큐에 있는 프로세스를 보여줍니다. 시스템의 load avarage를 나타냅니다.
   \* runq-sz : 각 프로세스 대기 시간
   \* plist-sz : 전체 프로세스 수
   \* ldavg-1 : 기준 시간 이전 1분간 평균 작업 부하 정보
   \* ldavg-5 : 기준 시간 이전 5분간 평균 작업 부하 정보
   \* ldavg-15 : 기준 시간 이전 15분간 평균 작업 부하 정보
![sar-q.JPG](https://cafe24.zendesk.com/hc/article_attachments/10071330280473/sar-q.JPG)

**-r** : 메모리, 스왑 공간의 이용 통계를 출력합니다.
   \* kbmemfree : 사용가능한 총 메모리의 양(k/bytes)
   \* kbmemused : 사용중인 총 메모리의 양(k/bytes), 커널에서 사용중인 메모리는 제외
   \* %memused : 사용된 메모리의 %양
   \* kbmemshrd : 시스템에서 공유메모리로 사용된 총 메모리의 양(k/bytes)
   \* kbbuffers : 커널에서 buffer 메모리로 총 사용된 메모리의 양(k/bytes)
   \* kbcached : 커널에서 cache data로 사용된 총 메모리의 양(k/bytes)
   \* kbswpfree : 사용가능한 스왑 공간의 양(k/bytes)
   \* kbswpused : 사용된 스왑 공간의 양(k/bytes)
   \* %swpused : 사용된 스왑 공간의 %양
![sar-r.JPG](https://cafe24.zendesk.com/hc/article_attachments/10071491562521/sar-r.JPG)









# 파일 시스템 모니터링 : 스토리지에 파일 시스템 액세스



# 1.fsck : 파일 시스템 오류 확인

요 명령어들은 파일을 검사하거나 수리해주는 명령어예요

사실 파일 검사는 부팅할 때 자동으로 리눅스가 파일 시스템을 점검해줘요. 그리고 손상된게 있으면 알아서 자동으로 복구도 해줍니다..

서버를 운영하지 않는 사람들은 딱히 쓸일은 많지 않지만.. 서버에서는 비상사태를 복구하는 것만큼 중요한게 없죠

중요한 명령어입니다 :)





**fsck**

**(filesystem check )**

**리눅스 파일 시스템을 검사하고 수리하는 명령어**



**e2fsck = fsck의 확장 명령어**

**# fsck [option] 장치명**

**# e2fsck [option] 장치명**





e2fsck가 확장버전이기 때문에 실질적으로 현재 리눅스 배포판에서 fsck명령 실행하면 e2fsck가 실행돼요.

fask명령은 손상된 디렉터리나 파일을 수정할 때 임시로 /lost+found 디렉터리에서 작업을 수행하고 정상적인 복구가 되면 사라집니다.



fsck 명령어를 수행하면 내부적으로 동작 단계는 다음과 같습니다.

![img](https://t1.daumcdn.net/cfile/tistory/997C86455C48CBE20F)

시작

단계1 - 블록들과 파일 크기 검사

단계2a - 중복된 이름이 있는지 검사

단계2b - 경로명 검사

단계3 - 연결성 검사

단계3b - Shadows/ACLs 인증

단계4 - 참조 수 검사

단계5 - 싸이클 그룹 검사



그릏구나~~ 대강 어느 단계에서 어떤 걸 점검하면서 이상 유무를 확인하는 과정입니다.

자세한 내용이 더 필요한 사람은 **[fsck 명령어의 수행 과정 문서](https://docs.oracle.com/cd/E23823_01/html/817-0403/tsfsck-1.html)** 참조 (링크)





fsck 실행 시 중요한거!

fack/e2fsck 명령어를 사용할 때는 마운트된 드라이브에서는 **절대절대** 사용하면 안됩니다. 만약에 마운트된 드라이브에 fsck를 수행하면 그 드라이브는 평생 망가질 확률이 높다고 보면 돼요.

그러므로 fsck를 수행하기 전에는 꼭! unmount작업을 해준 후 수행합시다.



**fsck를 한 번 사용해볼까요?**

자 먼저 df 명령어로 마운트 되어있는지 확인하고



재부팅으로 [마운트](https://jhnyang.tistory.com/12)가 현재 연결되지 않은 /dev/sdb1의 디스크에 fsck를 수행했어요

![img](https://t1.daumcdn.net/cfile/tistory/99AEE3475C48C8CE0D)

마지막 줄에 clean이라고 떴죠? 에러가 없다는 전혀 손상되지 않고 잘 있다는(?) 뜻입니다.

에러코드의 종류와 의미는 이러해요

![img](https://t1.daumcdn.net/cfile/tistory/99E9FC495C48C8FD0D)

에러가 있을 경우는 clean부문이 'error 2,'처럼 error + 숫자 형식으로 뜹니다.



마운트 되어 있을 경우에 수행하면 어떻게 뜰까요? ([마운트가 무엇인지? 어떻게 마운트 하는지는 이전 포스팅](https://jhnyang.tistory.com/12)을 참고해주세요)저번에 파티션 및 포맷 설정은 다 해줬으니 mount 명령어를 이용해서 재부팅으로 초기화된 마운트를 다시 연결해줬어요

![img](https://t1.daumcdn.net/cfile/tistory/991FCB4C5C48C9170D)

df 명령어가 마운트가 잘 됐음을 보여주네요

우분투에서 fsck를 실행해줬더니!! 마운트되어있기 때문에 할 수 없다고 나옵니다

![img](https://t1.daumcdn.net/cfile/tistory/99367F435C48C92B0F)

실제에서는 이러다가 망가지면 큰일나니 왠만하면 마운트된 상태에서는 하지 맙시다 !

이렇게 마운트되어 있을 경우 umount 해준 후 진행하기! 

![img](https://t1.daumcdn.net/cfile/tistory/996873485C48C96D10)

umount 하니까 fsck 명령어가 잘 작동된 것을 확인할 수 있습니다.



**
**

**자 그러면 어떤 상황에 주로 파일이 손상될까요?**

1) 시스템이 갑자기 shutdown! 갑자기 서버가 중지됐을 때, 전원이 나가버렸을 때 등등 이럴 때 파일 시스템이 손상을 입을 수 있습니다. 이럴 경우 서버의 갑작스런 종료로 인해 생겨난 파일 시스템 이상으로 재부팅시 파일시스템이 마운트되지 않는 경우가 종종 발생합니다. 이럴 경우 다시 시스템을 부팅하여 사용하기 이전에 fsck명령을 사용해 시스템상의 모든 파일 시스템을 점검하여 조치를 취해야 합니다.



하지만 요새 경우는 최신 저널링 파일 시스템 덕분에 충돌나서 다운되도 사실 fsck 안해줘도 된다네요. 좋아진 세상 ㅎㅎ

(저널링 파일 시스템은 파일 시스템에 대한 변경사항을 반영하기 전에 저널이라 부르는 로그에 변경사항을 저장하여 추적이 가능하게 만든 파일 시스템입니다.)



2) Clearing group locks improperly

\- 두 프로세스가 인지하지 못한채 동시에 서로 내부 구조나 내용을 변경했을 때 (lock이 제대로 안된 상황에 발생되겠죠)

3) Overriding the built-in file protection mechanisms

다른 프로세스에 의해서 한 파일이 열려있는 상태인데 그 상황에서 다른 프로세스가 그 파일을 삭제하려고 할 때

4) System debugger when used incorrectly

시스템 디버거가 잘못쓰여졌을 때

등등







이런 사항들에서 파일 손상이 일어날 수 있다네요 ㅎ 이해가 안가면 그냥 그러려니 읽고 넘어가면 됩니다.



**옵션 알아보기**



두 명령어의 옵션은 다음과 같습니다

| 옵션 | 내용                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | 명령 수행에 대한 확인 질문 없이 무조건 수행한다. (권장하지 않음) |
| -v   | 점검 내역 상세 보기 , 자세한 출력                            |
| -y   | 모든 응답을 다 yes로 해서 자동으로 실행하는 거 Attempt to fix detected problems automatically |
| -n   | 모든 질문에 대한 응답을 no로 취급한다 (체크만 하는 거) Avoid Repair, but Report Problems to Stdout |
| -f   | 파일 시스템이 이상 유무에 상관 없이 강제적으로 파일 시스템을 체크 Force a Filesystem Check Even if it's Clean |

더 많은 명령어가 있지만 그 외 명령어는 메뉴얼을 참조하도록 합시다



-f옵션을 사용한 것

fsck -f /dev/sdb1와 같아요

![img](https://t1.daumcdn.net/cfile/tistory/99586F3B5C48D1DF0F)



# 2. du : 디스크 사용량 출력

***해당 디렉토리***(파일)의 디스크 크기확인 명령어
(리눅스는 파일기반으로 객체를 관리함)

옵션없으면 현재 경로의 모든 디렉토리 크기를 MB단위로 출력

## **옵션**

| -h   | (human) 크기단위표시 추가                                    |
| ---- | ------------------------------------------------------------ |
| -a   | (all) 하위 디렉토리에 포함된 파일까지 추가 ->하위디렉토리 안에 각각 용량 표시 |
| -s   | 하위 디렉토리 없이 추가 -> 하위디렉토리 표시 없이 전체 용량표시 |

## **해석**

왼쪽은 1k 블록단위로 사용용량 표시 

오른쪽은 디렉토리 경로

디스크의 최소단위는 4k이기때문에 왼쪽에 4k인것은 빈 디렉토리



![img](https://blog.kakaocdn.net/dn/vv8Hk/btqD2Gbqh4e/qMH7Jg5LSEbSGh4rvwMic0/img.png)

![img](https://blog.kakaocdn.net/dn/SVCb2/btqD2bpsePg/koxmCFw8pZqY4FxNH3quI1/img.png)



##  **예시**

#### 1 .하위디렉토리 안에 '각각'용량 표시 : du -ah 



![img](https://blog.kakaocdn.net/dn/IeoTS/btqDw4LEx06/Y6Y0t3oIkKyFti20MjCYsk/img.png)du –ah 명령어



#### 2. 하위 디렉토리 없이 '전체'용량 표시 : du –sh 



![img](https://blog.kakaocdn.net/dn/omrW0/btqDwDm4u28/YS70q1d3e4Pywdee5qIJhk/img.png)du –sh 명령어



#### 3. 디스크용량이 가장 큰순으로 10개 정렬 : du –ah | sort –n –r | head –n 10 



![img](https://blog.kakaocdn.net/dn/NARj8/btqD3c175aa/Artu12dMkqaEkMx8fcAcy1/img.png)



#### 4. N단계 마다 디렉토리별 크기 찾기 : du –d N –h (디렉토리명) 

디렉토리 명시 없으면 루트디렉토리 이하에서 각 디렉토리별로 차지하는 파일크기 표시



![img](https://blog.kakaocdn.net/dn/byXNj8/btqDvZxp7k4/nYpz9PO1Or1QrLgroK5NA1/img.png)du –d N –h



이후에 가장 높은 파일크기를 차지하는 /usr, 또는 /var로 이동해서 어떤 파일이 있는지 샅샅이 뒤지기



![img](https://blog.kakaocdn.net/dn/eC0QAP/btqDyMXg0kj/YTruwlxYbkSApwic6fZSnK/img.png)



 

# 3. df : 디스크 여유 공간 확인

리눅스 시스템 ***전체***의(마운트 된) 디스크 여유 공간 확인
파일시스템,디스크크기, 사용량, 여유공간, 사용률, 마운트지점 순으로 나타남

## **옵션**

| -a (all)   | 모든 파일 시스템 출력                                       |
| ---------- | ----------------------------------------------------------- |
| -h (human) | 사람이 읽기 쉬운 형태(단위)로 출력 (기본은 킬로바이트 단위) |
| -T (type)  | 보여주는 목록을 파일시스테므이 타입으로 제한                |
| -l (local) | 출력하는 목록을 로컬 파일 시스템으로만 제한                 |

##  

## **해석**



![img](https://blog.kakaocdn.net/dn/b3tLzZ/btqD2vnGuin/qhLEi4xfP7asZcEKlNY1t1/img.png)



| 명칭            | 의미                               |
| --------------- | ---------------------------------- |
| Filesystem      | 리눅스에 마운트된 파일 시스템 목록 |
| Size(1K-blocks) | 전체용량                           |
| Used            | 사용량                             |
| Available       | 남은 용량                          |
| Use%            | 용량 대비 사용량에 대한 퍼센트     |
| Mounted on      | 마운트 된 지점(경로)               |

 

## **예시**

#### **1. 전체의(마운트 된) 디스크 여유 공간 확인 (단위추가) : df -h**



![img](https://blog.kakaocdn.net/dn/07hLI/btqDxuXyJDo/lECwaMvfnTnhA91Z3jklrk/img.png)df-h 단위추가



 

#### **2. \**전체의(마운트 된) 디스크 여유 공간 확인\** (파일 시스템의 유형추가) : df - Th**



![img](https://blog.kakaocdn.net/dn/cawVcZ/btqD1rlYfcN/UFWrK4r6Vj1aKKkqJ3qbjK/img.png)df-th



 



# 로그 파일과 시스템 모니터링

리눅스에서 로그파일(Log file)은 시스템의 동작 상태나 사용자 활동 등을 기록하는 파일로, 시스템 운영과 문제점 해결 등에 필수적으로 활용됩니다.



## 로그파일의 위치 및 종류

리눅스에서 로그 파일은 일반적으로 /var/log 디렉터리에 저장되며, 시스템 로그(dmesg, messages, syslog), 인증 로그(auth, auth.log), 웹 서버 로그(access, error), 애플리케이션 로그 등 다양한 종류의 로그가 존재합니다.



## 로그파일 분석

리눅스에서 로그 모니터링(Log monitoring)은 로그 파일을 실시간으로 분석하여, 시스템의 문제를 조기에 감지하고 대응하는 것을 말합니다. 대표적인 로그 모니터링 도구로는 logwatch, logrotate, syslog-ng, rsyslog, ELK 스택 등이 있으며, 이들 도구를 이용하여 로그 데이터를 수집, 필터링, 분석, 시각화할 수 있습니다. 이를 통해 시스템의 문제를 빠르게 파악하고 대응할 수 있습니다.



## 패킷 분석 및 디버깅 도구

리눅스에서는 다양한 패킷 분석 및 디버깅 도구를 제공하여 네트워크 트래픽 분석, 문제점 진단 등에 활용됩니다. 대표적인 도구로는 tcpdump, Wireshark, strace, gdb 등이 있습니다.



## tcpdump

리눅스/유닉스 계열 OS에서 조건식에 만족하는 네트워크를 통해 송수신 되는 패킷 정보를 표시해주는 프로그램입니다. 

 

> tcpdump 사용 방법과 다양한 옵션 등

프롬프트에서 tcpdump 명령을 입력해서 사용합니다. 다양한 옵션이 존재하고 조건부 부분에 표현 방식과 범위를 정해 다양한 형식으로 표현할 수 있습니다.

> **# tcpdump [옵션] [조건부]**

 

- 다양한 옵션

| -c 숫자                | 지정한 수 만큼 출력                               |
| ---------------------- | ------------------------------------------------- |
| -i 네트워크 인터페이스 | 지정한 네트워크 인터페이스를 경유하는 패킷을 출력 |
| -w file                | 출력한 패킷 정보를 파일로 만든다                  |
| -r file                | w 옵션으로 만든 파일을 읽는다                     |
| -v                     | 패킷 내용을 상세히 본다                           |

- 표현 방식

| 그리고 | and  | &&   |
| ------ | ---- | ---- |
| 또는   | or   | \|\| |
| 아니다 | not  | !    |

- 범위 방식

| 네트워크 | network, mask |
| -------- | ------------- |
| 출발지   | src           |
| 목적지   | dst           |
| 포트     | port          |
| 도메인   | host          |

 

> tcpdump 사용 예시

- **tcpdump -i eth0** : 네트워크 인터페이스 eth0를 지나는 패킷 덤프
- **tcpdump -i eth0 -c 5** : 네트워크 인터페이스 eth0를 지나는 패킷 덤프 5개
- **tcpdump -i eth0 tcp port 80** : TCP 80 포트로 통신하는 패킷 덤프
- **tcpdump -i eth0 src 192.168.1.18** : 출발지 IP가 192.168.1.18인 패킷 덤프
- **tcpdump -i eth0 dst 192.168.1.19** : 목적지 IP가 192.168.1.19인 패킷 덤프
- **tcpdump -i eth0 src 192.168.1.19 and tcp port 80** : 목적지 IP가 192.168.1.19이고 TCP 80 포트인 패킷 덤프
- **tcpdump -i eth0 dst 192.168.1.19** : 목적지IP가 192.168.1.19인 패킷 덤프
- **tcpdump host \**192.168.1.18\**** : 특정 호스트 IP(192.168.1.18)로 양방향 패킷 덤프
- **tcpdump src \**192.168.1.18\**** : 특정 호스트 중에서 출발지가 192.168.1.18인 패킷 덤프
- **tcpdump dst \**192.168.1.18\**** : 특정 호스트 중에서 목적지가 192.168.1.18인 패킷 덤프
- **tcpdump -w dump.log** : 결과를 파일로 저장
- **tcpdump -r dump.log** : 저장한 파일을 읽음
- **tcpdump port 22** : 포트가 양뱡항으로 22인 패킷 덤프
- **tcpdump src port 22** : 출발지 포트가 22인 패킷 덤프
- **tcpdump dst port 22** : 목적지 포트가 22인 패킷 덤프
- t**cpdump udp and src port 123** : UDP이고 출발지 포트가 123인 패킷 덤프
- **tcpdump src \**192.168.1.18\** and not dst port 22** : 출발지 IP가 192.168.1.18이고 목적지 포트가 22가 아닌 패킷 덤프



## Wireshark

Wireshark는 네트워크 패킷을 캡쳐하고 분석하는 오픈소스 도구입니다. 개념적으로 같은 네트워크 구간에서 이메일 혹은 메신저를 주고 받는데, 이 경우 Wireshark를 사용하는 제 3자는 이 둘 사이의 네트워크로 돌아다니는 패킷을 수신하여 PCAP이라는 파일 포맷으로 저장합니다.

PCAP은 Packet Capture의 약자로 네트워크 트래픽을 캡쳐하는 API를 구성하고 있습니다.
Wireshark는 자체 프로그램으로 네트워크 트래픽을 캡쳐하는 것이 아닌 운영체제에서 지원하는 캡쳐 라이브러리를 이용하여

패킷 정보를 수집합니다.

 

#### * Wireshark 설치 명령어

yum -y install wireshark yum -y install wireshark-gnome

 

#### * Wireshark 사용법 및 필터링

1. Wireshark 프로그램을 실행하면 아래와 같은 창이 나옵니다.

Interface List 중 패킷 정보를 확인할 이더넷 장치 선택 후 Start를 버튼을 눌러 실행하도록 합니다.



![img](https://blog.kakaocdn.net/dn/2m0B4/btqLRjNdMWC/qc3DwQVviNZK9IoXBVEZK0/img.png)



 

2. 시작시 아래와 같이 해당 이더넷 장치로 들어오거나 나가는 패킷을 실시간으로 확인할 수 있습니다.

Source는 패킷의 출발지, Destination은 패킷의 도착지로 확인하시면 됩니다.

빨간 네모 버튼을 선택하여 현재 이더넷 장치에 대한 캡쳐를 정지할 수 있습니다.

아래의 네모친 부분에서 패킷의 정보를 하나하나 바이트 단위로 확인할 수 있기 때문에 송수신간 정확한 데이터를 받았는지 비교 가능합니다.



![img](https://blog.kakaocdn.net/dn/F30S9/btqLW8K1AJO/bfz7l4ve3fD71EcUmZSHMK/img.png)



 

3. Wireshark 에서는 해당 이더넷 장치에 실시간으로 많은 패킷 정보가 들어오기 때문에 유저가 데이터 별로 선택하여 볼 수

있는 필터링 기능을 지원합니다.

 

\* Protocol 검색
*=> Filter 창에 검색하고자 하는 프로토콜 입력*
  *ex) tcp, udp, ssh, llc*



![img](https://blog.kakaocdn.net/dn/qbw6E/btqLWI6StEQ/9ln8MWoSZtMvPZPl344NMK/img.png)



 

\* MAC 검색
*=> Filter 창에 검색하고자 하는 MAC주소를 아래의 문법에 따라 입력*

*- Source와 Destination의 Mac주소를 한번에 검색할 경우*

 *ex) eth.addr=xx:xx:xx:xx:xx:xx*

*- Source의 Mac주소를 검색할 경우*

 *ex) eth.src=xx:xx:xx:xx:xx:xx*

*- Destination의 Mac주소를 검색할 경우*

 *ex) eth.dst=xx:xx:xx:xx:xx:xx*

 



![img](https://blog.kakaocdn.net/dn/DwWVR/btqLJWTdScJ/EOquvwAIu1ZlKAybTDxskK/img.png)



 

\* IP 검색
*=> Filter 창에 검색하고자 하는 IP주소를 아래의 문법에 따라 입력*

*- Source와 Destination의 IP주소를 한번에 검색할 경우*

  *ex) ip.addr==192.168.0.116*

*- Source의 IP주소를 검색할 경우*

  **ex) ip.src==192.168.0.116**

*- Destination의 IP주소를 검색할 경우*

  **ex) ip.dst==192.168.0.116**



![img](https://blog.kakaocdn.net/dn/brUDma/btqLQb2YQbB/HoeiSKkMJi5q64yTcPtDr1/img.png)



 

*=> 추가로 필터링 시 위의 조건을 다양하게 합쳐서 사용할 수 있습니다.*

*ex) ssh && ip.addr==192.168.0.116*

**ex) llc && eth.addr==xx:xx:xx:xx:xx:xx**



## strace : https://netmarble.engineering/strace-k-build-guide/

strace는 프로세스가 시스템 호출(system call)을 할 때마다 호출 정보를 출력하는 도구입니다. 이를 통해 프로그램의 동작을 추적하고, 문제가 발생한 시점을 파악할 수 있습니다. 예를 들어, 다음 명령어는 ls 명령어 실행 시 호출되는 시스템 호출 정보를 출력합니다.

```
sudo strace ls
```



**시스템콜?**

**'시스템콜(system call)'**이란 프로세스가 컴퓨터를 관리하는 시스템(system)인 운영체제에게 어떤 기능(서비스)를 사용하게 해달라고 요청(call)할 때 사용하는 방법입니다.

위에서 알려드린대로, 컴퓨터의 대부분의 활동은 **운영체제를 통해 실행 및 관리**가 됩니다.

실행중인 프로그램인 **'프로세스'**도 결국 **운영체제를 통해** 실행이 되고 관리가 되죠. 

예시를 들자면 **'운영체제'**는 회사 관리자고 **'프로세스'**는 말단 직원인겁니다. 

**'프로세스3'**이란 **직원이** 자기 자리에 앉아 자신의 프로그램 코드를 실행중이였는데, **만약 자기 프로그램외 특정 파일 데이터를 필요로 한다**고 쳐봅시다. 이럴 때 그냥 조용히 독자적으로 파일 데이터를 읽어들일 수 있을까요? 

**아니죠~** 멋대로 다른 파일을 읽어들이는 것도 문제지만 기본적으로 파일을 읽고, 메모리에 데이터를 올리는 것은 **운영체제의 역할**입니다.

이런 경우 '프로세스3(ps3)'는 관리자 운영체제에게 허락을 요청(call)을 할 수 밖에 없습니다.

*어떤 뭐뭐 파일 데이터가 필요하니 사용해도 되겠습니까?* 라고 말이죠.

비단 특정 파일이 필요한 경우만 해당되는게 아니죠~ 당연히 운영체제가 관리하는 모든 자원(네트워크, 디스크, 메모리 등등등)을 **'프로세스'**가 필요로 할 경우 전부다 이 **'시스템콜(system call)'을 통해 사용해야**합니다.

파일을 여는 것(open)도 그렇고, 기존 프로세스를 다른 프로그램으로 바꾸는 것(exec), 똑같은 프로세스를 하나 더 만드는 것(fork) 그리고 다른 프로세스에게 어떤 행위를 지시하는 시그널(신호)을 보낼 때(kill)도 말이죠. 

이런 이미지처럼 말입니다.





[![img](https://1.bp.blogspot.com/-iwKlSOLDkyQ/YAQOTP5zcDI/AAAAAAAAF7k/yXS7r_DXLhcw-bZd77xIYuC97dfxGbjrQCLcBGAsYHQ/w640-h390/20210117_191459.png)](https://1.bp.blogspot.com/-iwKlSOLDkyQ/YAQOTP5zcDI/AAAAAAAAF7k/yXS7r_DXLhcw-bZd77xIYuC97dfxGbjrQCLcBGAsYHQ/s928/20210117_191459.png)



그리고 그런 시스템 콜들은 실제로 **운영체제에서 사용하라고 만들어놓은 코드들(함수)로**, 프로그래밍을 할 때 **시스템콜이 들어있는 헤더파일을 불러와서 사용**합니다.

'리눅스인 경우'에는 man 페이지에 **'시스템 콜(함수)'가** 어떤 헤더파일에 들어있고, 그 함수에서 사용하는 변수나, 함수의 이름들 또 매개변수를 무엇을 받으며, 어떤 값을 반환하는지 등등 자세하게 정보가 적혀있습니다. 



## gdb

gdb는 C/C++ 프로그램 디버깅에 사용되는 명령어 기반 도구입니다. 프로그램 실행 중에 원하는 지점에서 중지하고, 변수 값 등을 확인할 수 있습니다. gdb를 이용해 프로그램이 비정상 종료되는 원인을 찾을 수 있습니다.

**디버그란**

디버그는 컴퓨터로 실행되는 프로그램에 오류가 있을 경우, 이 오류를 해결하는 방법 및 행위를 말한다. 최초의 컴퓨터 버그는 1947년 실제 컴퓨터 부품 내에 들어가 오동작을 일으킨 벌래였다.

[![img](https://lh3.googleusercontent.com/--_RCbGfJ33k/YUvd1pxXvrI/AAAAAAAA7aI/TZlKQAaoce4RKXzm4DyTSIp7rW_myOjKACLcBGAsYHQ/image.png)](https://lh3.googleusercontent.com/--_RCbGfJ33k/YUvd1pxXvrI/AAAAAAAA7aI/TZlKQAaoce4RKXzm4DyTSIp7rW_myOjKACLcBGAsYHQ/image.png)

최초의 컴퓨터 버그(1947)

디버그를 위해서는 다음과 같은 기본적인 기능이 필요하다. 여기서, 브레이크포인트(break point)는 디버깅 실행 중 멈추는 지점을 의미한다. 모든 디버거는 이와 같은 기본 기능을 지원한다.

- 브레이크포인트 설정
- 브레이크포인트까지 계속 실행
- 명령행 한단계 실행
- 함수 진입
- 함수 빠져나오기
- 현재 변수값 확인


다음은 gdb의 명령어들입니다.



| gdb 명령어                     | 설명                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| gdb -q [실행파일명]            | gdb를 복잡한 문구의 출력 없이 뜨게 합니다.                   |
| run (r)                        | 바이너리를 실행합니다.                                       |
| run [인자1] [인자2]            | 인자1과 인자2를 인자로 프로그램 실행합니다.                  |
| continue (c)                   | 다음 브레이크 포인트까지 실행합니다.                         |
| quit (q)                       | 바이너리를 종료합니다.                                       |
| disassemble (disas) [함수이름] | 특정 함수의 어셈블리 코드를 출력합니다. (ex) set disassemble main ) |
| info function (info func)      | 특정 함수의 정보를 출력합니다.                               |
| info break delete              | 모든 브레이크포인트를 제거합니다.                            |
| info break delete [숫자]       | 특정한 브레이크 포인트를 제거합니다.                         |
| info reg                       | 특정 레지스터의 정보를 출력합니다.                           |
| break function                 | 함수에 브레이크포인트를 겁니다.                              |
| b* function                    | 특정 함수에 브레이크 포인트를 겁니다. ( ex) b *main+10 )     |
| b* [주소]                      | 특정 주소에 브레이크 포인트를 겁니다.                        |
| stepi (si)                     | step into로써, 코드를 한 줄씩 실행하는데, 함수를 만나면 그 안으로 들어갑니다. |
| nexti (ni)                     | next into로써, 코드를 한 줄씩 실행하는데, 함수를 만나면 그 함수 안으로 들어가지 않습니다. |
| print [함수명]                 | 해당 함수의 주소를 출력합니다.                               |
| print $reg (p $reg)            | 해당 레지스터의 값을 출력합니다.                             |
| p/[출력형식] [변수명]          | 출력형식에 맞추어 변수값을 출력합니다.                       |
| x/[범위]i [주소]               | 특정주소 범위만큼 어셈블리로 출력합니다.                     |
| x/[범위]s [주소]               | 특정주소 범위만큼 문자열로 출력합니다.                       |
| x/[범위]wx [주소]              | 특정 주소 범위만큼 16진수 4bytes 단위로 출력합니다.          |
| set {type} [주소]              | 특정 메모리에 값을 지정합니다. ( ex) set {int}0x8048300 = 100 ) |
| set $[reg]                     | 특정 레지스터에 값을 지정합니다. ( ex) set $eip = 0x41414141 ) |
| set disassembly-flavor intel   | 어셈블리어를 intel 형식으로 출력합니다.                      |
| set disassembly-flavor att     | 어셈블리어를 at&t 형식으로 출력합니다. ( 기본 )              |
| set follow-fork-mode child     | 자식프로세스에 gdb를 붙여줍니다.                             |
| set follow-exec-mode new       | exec로 실행되는 바이너리에 gdb를 붙여줍니다.                 |
| finish                         | 현재 함수를 수행하고 빠져나갑니다.                           |
| u                              | 현재 루프를 빠져나갑니다.                                    |
| disas [주소] [주소]            | 주소 사이의 어셈블리 코드를 출력합니다.                      |
| list                           | 디버깅 중인 프로그램 C언어 소스를 보여줍니다.                |
| bt                             | 현재 프로그램 스택에 있는 내용을 보여줍니다.                 |

명령어는 줄여쓰기가 가능합니다. 예를 들어서 **run**은 **r**이라고 해도 되고,
 **set disassembly-flavor intel**도 또한 줄여서 **set dis int**라고 표현이 가능합니다.