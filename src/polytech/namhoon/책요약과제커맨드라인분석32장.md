---
layout : home
---
# <32장 위치 매개변수>



## 1. 커맨드라인 항목 접근

쉘은 **위치 매개변수**라는 변수의 집합을 제공 -> 커맨드라인 명령의 개별 요소들을 가지고 있으며 변수들은 0~9까지의 이름을 붙인다. 

<ex> 변수 $0부터 $9까지의 값을 표시하는 스크립트

\#! / bin/ bash 

posit-param : script to view command line parameters 

echo "

\ \$0 = $0

 \ $1 = $1

 \ $2 = $2
 \  \$3 = $3 
 \ $4 = $4 
 \ \$5 = $5 
\\ $6 = $6 
\ $7 = $7 
\\$8 = $8 
\\$9 = $9"



<1> 커맨드라인 인자 없이 출력하면 아래처럼 나옴
-> 인자가 없는 경우에도 $0은 항상 커맨드라인의 첫번째 항을 가짐 = 실행되고 있는 프로그램의 경로

[me@linuxbox ~]$ posit-param 

$0 = /home/me/bin/posit-param 

$1 = 

$2 = 

$3 = 

$4 = 

$5 = 

$6 = 

$7 = 

$8 = 

$9 =



<2> 커맨드라인 인자를 입력하고 실행해보자

[me@linuxbox ~]$ posit-param 

$0 = /home/me/bin/posit-param a b c d

$1 = a

$2 = b

$3 = c

$4 = d

$5 = 

$6 = 

$7 = 

$8 = 

$9 =



## 2. 인자 수 확인

쉘은 커맨드라인의 인자 수를 넘겨주는 변수 $#을 제공한다.
<ex>
echo " Number of arguments: $# 
\ $0 = $0 
\ $1 = $1 
\ $2 = $2 
\ $3 = $3 
\ $4 = $4 
\ $5 = $5 
\ $6 = $6 
\ $7 = $7 
\ $8 = $8
\ $9 = $9 



결과는 이와 같다. 

[me@linuxbox ~]$ posit-param a b c d 
**Number of arguments: 4** 
$0 = / home/ me / bin/ posit-param 
$1 = a 
$2 = b 
$3 = c
$4 = d 
$5 = 
$6 = 
$7 = 
$8 = 
$9 =



### 3. shift - 다수의 인자에 접근 

수많은 인자가 주어진다면? 어떻게 처리할 것인가?

스크립트가 `shift` 명령어를 만나면 커맨드라인 매개변수를 앞으로 차례대로 한 칸씩 당깁니다.

즉 `$3` -> `$2`가 되고,
`$2` -> `$1`가 되며,
기존의 `$1`의 값은 사라집니다.

이를 응용하면 매개변수의 개수가 얼마나 될지 모를 때 반복해서 참조하기 유용합니다.

```bash
$ cat test1
#!/bin/bash
count=1
while [ -n "$1" ]
do
        echo "parameter #$count : $1"
        (( count = count + 1 ))
        shift
done

$ ./test1 A B C D E
parameter #1 : A
parameter #2 : B
parameter #3 : C
parameter #4 : D
parameter #5 : E
```

> **코드 리뷰**
>
> - `while` 문은 `shift`로 매개변수가 앞으로 하나씩 당겨지다가 아무런 값이 존재하지 않게 되면 종료됩니다.
> - `count` 변수는 `1`부터 매개변수의 개수까지 `1`씩 증가합니다.
> - `shift`를 통해 매개변수가 하나씩 앞으로 당겨지면서 `$1`이 되기 때문에 계속해서 `$1`을 참조하면 됩니다.



### cf) 간단한 응용프로그램 : shfit 없이 위치 매개변수 사용 

`# ! / bin/ bash  `

`# file_info: simple file information program  `

`PROGNAME=$(basenarne $0)`

`if [[ -e $1 ]]; `

`then  echo -e "\ nFile Type : "`

`  file $1  `  

`echo -e "\ nFile Status: "  `

`stat $1  `

`else  `

`echo "$PROGNAME: usage: $PROGNAME file " >&2`

`  exit 1  `  

`fi`

이 프로그램은 파일 종류 (file 명령어로 확인된)와 지정된 파일의 (stat 명령어를 사용하여) 를  표시한다. 이 프로그램의 한 가지 홍미로운 점은 PROGNAME 변수다. 그것은 basename $0 명령으로부터 그 결과를 가져온다. basename 명령 는 경로명의 앞 부분을 제거하고 파일의 기본 이름만을 남긴다. 이 예제에서 basename은 제 프로그램의 전체 경로명인 매개변수 $0 에서 경로명의 선두를  제거한다. 이 값은 이 프로그램 끝의 사용법처럼 메시지를 구성하는 데 유용하다. 이러한 방식 으로  코딩하면 그 메시지가 프로그램명에 따라 자동으로 조절되기 에 크립트 을 변경할 수 있다



### 4. 쉘 함수에서 위치 매개변수의 사용

인자를 전달하기 위해 쉘 스크립트에 위치 매개변수를 사용했던 것처럼 쉘 함수에 인자를 전달할 수 있다. 

<ex> 쉘 함수 file_info를 포함한 스크립트가 파일명 인자와 함께 함수를 하도록 작성

`file_info () {`

`file_info: function to display file information` 

`if [ [ -e $1 ]] ; then` 

`echo -e "\nFile Type :"` 
`file $1 echo -e "\ nFile Status: "`
`stat $1` 
`else` 
`echo` 
`"$FUNCNAME : usage : $FUNCNAME file" >&2` 
`return 1` 
`fi` 
`}` 



위 처럼 작성하면 해당 인자가 함수에 전달된다.

**이때 앞선 예시에서 PROGNAME 변수가 쉘 변수 FUNCNAME으로 변경된다!**

쉘은 현재 실행된 쉘 함수를 계속 추적하여 자동으로 이 변수를 갱신한다. 

$0은 항상 커맨드라인 첫 번째에 경로명(즉, 프로그램명)을 가지지만 우리가 예측한 것처럼 쉘 함수명은 가지고 있지 않다.

### 

### 5. 위치 매개변수 전체 제어

 위지 매개 변수 전부를 그룹으로 관리하면 도움이 된다. 예를 들어, 우리가 다른 프로그램을  감싸는 래퍼 (wrapper) 를 작성하기를 원한다면. 이는 그 프로그램의 실행을 간소화하는 스크립트나  쉘 함수를 만든다는 것을 의미한다. 래퍼는 커맨드라인 옵션 목록을 공급하고 나서 인자 목록을 하위 레벨 프로그램에 전달한다.  쉘은 이러한 목적으로 두 가지 특수한 매개변수를 제공한다. 이들은 둘 다 위치 매개변수의 전체  목록으로 확장되지만 미묘한 방식 차이가 있다. 아래 표는 이들 매개변수를 설명한다. 

| 매개변수 | 설명                                                         |
| -------- | ------------------------------------------------------------ |
| $*       | 항목 1부터 시작하여 위치 매개변수 목록으로 확장된다 이것을 쌍 따옴표로 둘러싸면,  쌍 따옴표 내의  문자열 모두가 위치 매개변수로 확장되고 각각 IFS 쉘 변수의 첫 번째 문자(기본값은 페이스) 에 의해  구분된다. |
| $@       | 항목 1부터 시작하여 위치 매개변수 목록으로 확장된다. 이것을 쌍 따옴표로 둘러싸면, 각 위치 매개변수는 쌍 따옴표로 구분된 단어로 확장된다. |

\#! / bin/ bash  

#posit-params3 : script to demonstrate $* and $@  

print_params () {  

echo "\$1 = $1" 

 echo "\$2 = $2"

  echo "\$3 = $3" 

echo "\$4 = $4" } 

pass_params () {  

echo -e "\n" '$* : '; print_params $* 

 echo -e "\ n" '"$*" : '; print_params "$*"  

echo -e "\n" '$@ :'; print_params $@  

echo -e "\ n" ' ’"@": ' ; print params "$@"  

}  

pass_params "word" "words with spaces"

이 난해한 프로그램은 word 와 words with spaces 는 두 인자를 만들고 pass_params 함수에 전달한다. 결국 그 함수는 특수 매개변수 $*와 $@로 시용- 가능한 가지 방식 으로 print_params 함수에  인자들을 전달한다. 이 스크립트의 실행 결과는 방식에 따라 차이점 을 보여준다. 

[me@linuxbox ~]$ posit-param3  

$* : 

 $1 = word  

$2 = words  

$3 = with  

$4 = spaces 



 "$*" :  

$1 = word words with spaces 

 $2 =  

$3 =  

$4 =  



$@ :  

$1 = word  

$2 = words  

$3 = with  

$4 = spaces  



"$@" :  

$1 = word  

$2 = words with spaces  

$3 =  

$4 =

$＊와 $＠는 word . words. with. spaces 라는 모두 네 단어 를 생성한다. 

"＄*"는 word words with  spaces 라는 한 단어를 생성한다. 

’'＄＠'’ 는 word 와 words with spaces 두 단어 를 생성한다.  이는 우리가 의도한 것과 일치한다. 

이것으로 얻을 수 였는 교훈은, 쉘이 위치 매개변수 목록을 얻을 수 있는 4가지 방식 을 제공함에도 불구하고 **<u>’'＄＠'’</u>** 는 각각의 위치 매개변수 그대로를 유지하기 때문에 **<u>가장 많이 사용되고 유용하다.</u>**



### 6. 완전한 응용 프로그램

우리는 오랜만에 sys_info_page 프로그램으로 다시 작업할 예정이다. 다음과 같이 프로그램에 여 러 커맨드라인 옵션을 추가하려고 한다.  

**• 출력 파일**  : 프로그램 출력을 저장할 파일명을 지정하기 위한 옵션을 추가할 것이다. 이 옵션은  

-f file 나 --file file 로 지정한다.  

**• 대화식 모드** : 이 옵션은 출력 파일명을 사용자에게 표시하고 그 파일의 존재 여부를 확인한 다. 만약 존재한다면 사용자에게 해당 파일을 덮어쓰기 전에 물어본다. 이 옵션은 -i 또는  --interactive로 지정한다 

**• 도움말 : ** -h 나 --help를 입력하면 시용법이 표시된다.



<커맨드라인 처리를 위한 코드>

usage () { 

 echo "$PROGNAME : usage : $PROGNAME [-f file I -i]"  

return 

} 

process command line options  

interactive=  

filename=  

while [[ -n $1 ]]; do  

case $1 in   

 -f I --file)  shift  
                  filename=$1

​                   ;;

-i I --interactive)  interactive=1

​                              ;;

-h I --help)          usage

​                             exit
​                             ;;

*)                         usage >&2

​                             exit 1
​                             ;;  

esac  

shift

done  



먼저 . 우리는 help 옵션이 호출되거나 알 수 없는 옵션인 경우에 메시지 를 표시하는 usage 라는 쉘  함수를 추가한다.  

그 다음, 처리 를 실행한다. 이 루프는 위치 매개변수 $1 의 값이 빌 때까지 계속된다. 루프가  종료되기 위해서는 루프의 끝에서 shift 명령어로 위치 매개변수를 전진시킨다.  

루프 내에서 case 문은 현재 위치 매개변수가 이 프로그램이 지원하는 옵션과 일치하는지 확인하기  위해 사용된다. 만약 지원하는 매개변수이면 에 따라 동작한다. 지원하지 않는다면, 사용법을 표시하고 스크립트는 오류와 함께 종료된다.



-f 매개변수 전개
이 옵션이 입력되면 추가적으로 shift가 수행되어 위치매개변수 $1 에는 -f 옵션에 제공된 파일명이 전달된다.  

다음은 대화식 모드를 구현하는 코드다.  



interactive mode  

if [ [ -n $interactive ]] ; then  

while true ; do  

read -p "Enter name of output file: " filename  

if [ [ -e $/ilename ] ] ; then  

read -p " ' $filename ' exists . Overwrite ? [y/ n/ q ] > "  

case $REPLY in  

Y|y) break ;;

Q l q) echo "Program terminated . "  exit;; 

 *) continue ;; 

esac  

elif [ [ - z $filename ] ]; then  

continue  

else  

break  

fi  

done  

fi  

만약 interactive 변수가 비어있다면, 파일명 프롬프트 와 파일 조작 코드가 존재하는 무한 루프가  시작된다. 

원하는 출력 파일 이 이미 존재한다면, 덮어쓰기를 위한 프롬프트를 표시 하고 사용자가  다른 파일명을 선택하거나 프로그램을 종료 하도록 한다. 

사용자가 기존 일을 덮어 쓰기로 결정 한다면 break문이 실행되어 루프는 종료된다. 

여기서 case문은 사용자가 덮어쓰기나 종료를 선택하는 경우만 감지한다는 것을 명심해라. 다른 것을 선택하면 루프는 계속되고 사용자에게 다시 프롬프트를 표시한다.  



출력파일명 옵션을 구현하기 위해 먼저 기존 페이지 작성코드를 쉘 함수로 변환해야 한다. 그 이유는 순식간에 없어져 버릴 수 있기 때문이다.   

write_html_page () { 

cat «- _EOF _     

< HTML >

< HEAD >

< TITLE > $TITLE < /TITLE >

< /HEAD >

< BODY >

< H1 > $TITLE < /H1 >

< P > $TIME_STAMP< /P> 

$(report_uptime)  

$(report_disk_space)  

$(report_home_space)

< /BODY >

< /HTML >

_ EOF _

return

}    



#output html page  

if [ [ - n $filename ]] ; then  

if touch $filename && [[ -f $filename ]]; 

then  write_html_page > $filename  

else  

echo "$PROGNAME: Cannot write file '$filename'" >&2  

exit 1  

fi 

 else  

write_html_page

fi



  이 코드는 -f 옵션의 흐름을 제어한다. 파일의 존재를 확인하고 만약 있다면 그 파일이 정말로 쓰기 가능한지 확인하기 위해 테스트한다. 이를 위해 touch 명령을 실행하고 이어서 해당 파일이 일반 파일인 지 확인한다. 

이 두 테스트는 유효하지 않은 경로명이 입력되는 상황 (touch는 실패한다)  을 처리하고,  만약 파일이 존재한다면 일반 파일로 인지한다.  

위에서 볼 수 있는 것처럽, write_html_page 함수는 페이지를 실제로 생성하기 위해 호출된다. 출력 결과는 파일명 변수 값이 없다면 표준 출력 으로 직접 보내지거나 지정 된 파일로 보내 진다.
