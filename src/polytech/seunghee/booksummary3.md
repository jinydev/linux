---
layout: home
---

# 30: 문제해결

: 이 장에서는 스크립트에서 발생하는 흔한 오류들과 문제를 찾아 해결하는 방법들을 살펴볼 예정이다.

## 1. 구문 오류

: 구문 오류에는 쉘 구문 요소의 잘못된 타이핑을 포함한다. 대부분 이러한 오류는 스크립트를 실행하는 경우 쉘에 혼란을 일으킬 수 있다.

### 1.1 따옴표 누락

```sql
#!/bin/bash
# trouble : script to demonstrate common errors
number=l
if [ $number = 1 ]; then
	echo "Number is equal to 1.
else
	echo "Number is not equal to 1. "
fi
```

```sql
[me@linuxbox ~]$ trouble
/ home/ me/bin/ trouble : line 10 : unexpected EOF while looking for matching '" '
/home/me/bin/trouble : line 13: syntax error: unexpected end of file
```

프로그램에서 따옴표가 누락된 곳이 아닌 그 이후의 행 번호를 보고한다. bash는 나머지 마침 따옴표를 찾을 때까지 계속되고 두 번째 echo 명령어 이후에 바로 나타난다. 그것은 if문이 인용된(열리기만 한) 문자열에 포함되기 때문이다.

### 1.2 예상치 못한 토큰이나 토큰 누락

또 다른 흔한 실수는 if나 while문 처럼 합성 명령어를 제대로 완료하지 않는 것이다.

```sql
#!/bin/bash
# trouble : script to demonstrate common errors
number=l
if [ $number = 1 ] then
echo "Number is equal to 1."
else
echo "Number is not equal to 1. "
fi
```

```sql
[me@linuxbox ~)$ trouble
/ home / me / bin/trouble : line 9: syntax error near unexpected token ' else'
/ home / me / bin / trouble : line 9 : · else '
```

명령어 목록에서 if가 종료 코드를 평가할 다른 명령어로 해석된다. 그 다음 만나게 되는 것은 else지만 쉘이 그것을 명령어 이름이 아닌 예약어(쉘에서 특수한 의미를 가진 단어)로 인식하기 때문에 적합하지 않다.

### 1.3 예상 외의 확장

```sql
#! / bin/ bash
# trouble: script to demonstrate common errors
number=
if [ $number = 1 ]; then
echo "Number is equal to 1. "
else
echo "Number is not equal to 1. "
f
```

```sql
[me@linuxbox ~]$ trouble
/home/me/bin/ trouble : line 7 : [ : = : unary operator expected
Number is not equal to 1.
```

= 연산자는 이항 연산자 (양쪽에 값이 필요한)인데 첫 번째 값이 없기 때문에, test 명령어는 대신 단항 연산자(-z과 같은)를 요구한다. 게다가 test가 실패했기 때문에(오류로 인해) if 명령어는 0이 아닌 종료 코드를 받게 되고 그에 따라 행동한다. 그리고 두번째 echo 명령어가 실행된다. 이 문제는 test 명령의 첫 번째 인자 주위를 따옴표로 감싸면 해결할 수 있다.

## 2. 논리 오류

- 잘못된 조건식 : if/ then/else 문은 잘못된 을 수행하는 부정확한 코드를 만들기 쉽다.
- "Off by one" 오류들 : 카운터를 사용하여 루프를 코딩할 때, 올바른 지점에서 카운트가 종료되기 위해서 1이 아닌 0부터 루프가 시작한다는 것을 간과하는 경우가 있다.
- 예상치 못한 상황 : 스페이스가 포함된 파일명처럼 예상치 못한 확장도 이러한 부류에 포함될 수 있다.

### 2.1 방어적 프로그래밍

프로그래밍을 할 때 가정을 검증하는 것은 중요하다. 이는 프로그램들과 스크립트에서 사용되는 명령어들의 종료 상태를 평가함에 있어 주의해야 한다는 것을 의미한다.

### 2.2 입력값 검증

프로그램이 입력을 받는 경우 일반적으로 좋은 프로그래밍 규칙은 어떤 입력 값읻든 처리 가능해야 한다는 것이다. 이는 항상 추가적인 처리를 위해 꼭 유효한 입력만을 허용하도록 주의 깊게 확인해야 한다.

## 3. 테스팅

테스팅은 모든 종류의 소프트웨어 개발에서 중요한 단계다. 물론 스크립트도 포함해서 말이다. 경험은 버그들을 찾기 쉽게 해준다. 그리고 개발 단계에서 일찍 버그를 발견하게 되면 수정하는 비용도 덜 든다.

### 3.1 스텁(Stub)

스크립트 개발의 최초 단계에서 작업의 절차를 확인하기 위해 가치있는 기법이다. 가장 중요한 변화는 rm 명령어 바로 앞에 echo 명령어가 놓인 것이다. 이는 그 명령어를 허용하지만 실행하는 대신에 그 확장된 인자 목록이 표시된다. 이 변경은 코드의 안전한 수행을 위한 것이다. 코드 조각의 끝 부분에 테스트랄 완료하고 스크립트의 나머지 부분에서 실행되는 것을 막기 위해 exit 명령어를 두었다. 이것은 스크립트 설계에 따라 다양할 것이다. 

### 3.2 테스트 케이스

효과적인 테스트를 위해 좋은 테스트 케이스를 개발하고 적용하는 것 또한 중요하다. 테스트 케이스는 엣지 케이스(edge ase) 와 코너 케이스(co rner case) 를 반영하여 입력 데이터와 작동 상태를 주의 깊게 선택하는 것으로 이뤄진다. 

디자인과 마찬가지로 테스팅도 시간에 비례한다. 모든 스크립트 가능을 광범위하게 테스트할 필요는 없다. 가장 중요한 것이 무엇인지 확인하는 것이 정말 중요하다. 만약 코드가 오동작하면 큰 피해를 입을 수 있기 때문에, 그 설계와 테스팅 둘 다 타당한지 신중하게 숙고해야 한다.

## 4. 디버깅

어떤 면에서 "문제’’란 항상 프로그래머의 예상대로 수행되지 않은 스크립트를 의미한다. 만약 이러한 경우라면, 스크립트가 실제 어떻게 동작하고 왜 그런지 주의 깊게 확인할 필요가 있다. 버그를 발견하는 일은 때때로 많은 탐색 작업을 포함할 수 있다.

### 4.1 문제 발생 지역 발견

특히 긴 스크립트에서 문제가 되는 스크립트 영역을 종종 격리하는 게 유용하다. 항상 실제 오류는 아닐 수 있지만 코드 분리는 실제 원인에 대한 실마리를 제공할 것이다. 코드를 격리시키는 데 쓰이는 한 가지 기법은 스크립트 일부를 주석화하는 것이다.

### 4.2 트레이싱(tracing)

스크립트의 일부가 전혀 실행되지 않거나 잘못된 시간 혹은 잘못된 순서로 실행되는 경우다. 프로그램의 실제 흐름을 보기 위해 우리는 트레이싱 tracing 이란기 법을 사용한다.

트레이싱의 한 가지 방법은 스크립트 내에 실행 위치를 표시하는 정보 메시지를 포함시키는 것이다.

트레이싱을 활성화하여 확장이 적용된 명령어를 보게 된다. 더하기 기호는 일반적인 출력과 구별하여 트레이스 출력을 가리킨다. 더하기 기호는 트레이스 출력의 기본 문자다. 그것은 PS4 프롬프트 문자열) 쉘 변수에 포함된다. 이 변수의 내용은 프롬포트를 더 유용하게 만들기 위해 조절이 가능하다.

### 4.3 실행 중에 값 확인

때때로 실행 중에 스크립트의 내부 동작을 할 변수의 내용을 표시하는 경우 유용하다.

변수의 값을 할 뿐만 아니라 나중에 식별해서 제거하기 쉽록당 해당 줄을 주석으로 표시한다. 이 기법은 특히 스크립트 내의 루프와 연산의 동작을 확인할 때 유용하다.